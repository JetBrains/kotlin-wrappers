// Generated by Karakum - do not modify it manually!

@file:JsModule("node:http")

package node.http

import node.net.Socket
import node.net.Server as NetServer

/**
 * @since v0.1.17
 */
open external class Server<Request : IncomingMessage, Response : ServerResponse<*>> : NetServer {
    constructor (requestListener: RequestListener<Request, Response> = definedExternally)
    constructor (
        options: ServerOptions<Request, Response>,
        requestListener: RequestListener<Request, Response> = definedExternally,
    )

    /**
     * Sets the timeout value for sockets, and emits a `'timeout'` event on
     * the Server object, passing the socket as an argument, if a timeout
     * occurs.
     *
     * If there is a `'timeout'` event listener on the Server object, then it
     * will be called with the timed-out socket as an argument.
     *
     * By default, the Server does not timeout sockets. However, if a callback
     * is assigned to the Server's `'timeout'` event, timeouts must be handled
     * explicitly.
     * @since v0.9.12
     * @param [msecs=0 (no timeout)]
     */
    fun setTimeout(
        msecs: Number = definedExternally,
        callback: (socket: Socket) -> Unit = definedExternally,
    ) // this

    fun setTimeout(callback: (socket: Socket) -> Unit) // this

    /**
     * Limits maximum incoming headers count. If set to 0, no limit will be applied.
     * @since v0.7.0
     */
    var maxHeadersCount: Double?

    /**
     * The maximum number of requests socket can handle
     * before closing keep alive connection.
     *
     * A value of `0` will disable the limit.
     *
     * When the limit is reached it will set the `Connection` header value to `close`,
     * but will not actually close the connection, subsequent requests sent
     * after the limit is reached will get `503 Service Unavailable` as a response.
     * @since v16.10.0
     */
    var maxRequestsPerSocket: Double?

    /**
     * The number of milliseconds of inactivity before a socket is presumed
     * to have timed out.
     *
     * A value of `0` will disable the timeout behavior on incoming connections.
     *
     * The socket timeout logic is set up on connection, so changing this
     * value only affects new connections to the server, not any existing connections.
     * @since v0.9.12
     */
    var timeout: Double

    /**
     * Limit the amount of time the parser will wait to receive the complete HTTP
     * headers.
     *
     * If the timeout expires, the server responds with status 408 without
     * forwarding the request to the request listener and then closes the connection.
     *
     * It must be set to a non-zero value (e.g. 120 seconds) to protect against
     * potential Denial-of-Service attacks in case the server is deployed without a
     * reverse proxy in front.
     * @since v11.3.0, v10.14.0
     */
    var headersTimeout: Double

    /**
     * The number of milliseconds of inactivity a server needs to wait for additional
     * incoming data, after it has finished writing the last response, before a socket
     * will be destroyed.
     *
     * This timeout value is combined with the
     * `server.keepAliveTimeoutBuffer` option to determine the actual socket
     * timeout, calculated as:
     * socketTimeout = keepAliveTimeout + keepAliveTimeoutBuffer
     * If the server receives new data before the keep-alive timeout has fired, it
     * will reset the regular inactivity timeout, i.e., `server.timeout`.
     *
     * A value of `0` will disable the keep-alive timeout behavior on incoming
     * connections.
     * A value of `0` makes the HTTP server behave similarly to Node.js versions prior
     * to 8.0.0, which did not have a keep-alive timeout.
     *
     * The socket timeout logic is set up on connection, so changing this value only
     * affects new connections to the server, not any existing connections.
     * @since v8.0.0
     */
    var keepAliveTimeout: Double

    /**
     * An additional buffer time added to the
     * `server.keepAliveTimeout` to extend the internal socket timeout.
     *
     * This buffer helps reduce connection reset (`ECONNRESET`) errors by increasing
     * the socket timeout slightly beyond the advertised keep-alive timeout.
     *
     * This option applies only to new incoming connections.
     * @since v24.6.0
     * @default 1000
     */
    var keepAliveTimeoutBuffer: Double

    /**
     * Sets the timeout value in milliseconds for receiving the entire request from
     * the client.
     *
     * If the timeout expires, the server responds with status 408 without
     * forwarding the request to the request listener and then closes the connection.
     *
     * It must be set to a non-zero value (e.g. 120 seconds) to protect against
     * potential Denial-of-Service attacks in case the server is deployed without a
     * reverse proxy in front.
     * @since v14.11.0
     */
    var requestTimeout: Double

    /**
     * Closes all connections connected to this server.
     * @since v18.2.0
     */
    open fun closeAllConnections()

    /**
     * Closes all connections connected to this server which are not sending a request
     * or waiting for a response.
     * @since v18.2.0
     */
    open fun closeIdleConnections()

    override fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun emit(
        event: String,
        vararg args: Any?,
    ): Boolean

    override fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    @web.events.JsEvent("close")
    override val closeEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("connection")
    override val connectionEvent: node.events.EventInstance<js.array.Tuple1<Socket>>

    @web.events.JsEvent("error")
    override val errorEvent: node.events.EventInstance<js.array.Tuple1<js.errors.JsError>>

    @web.events.JsEvent("listening")
    override val listeningEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("checkContinue")
    open val checkContinueEvent: node.events.EventInstance<js.array.Tuple2<Request, Response>>

    @web.events.JsEvent("checkExpectation")
    open val checkExpectationEvent: node.events.EventInstance<js.array.Tuple2<Request, Response>>

    @web.events.JsEvent("clientError")
    open val clientErrorEvent: node.events.EventInstance<js.array.Tuple2<js.errors.JsError, node.stream.Duplex>>

    @web.events.JsEvent("connect")
    open val connectEvent:
            node.events.EventInstance<js.array.Tuple3<Request, node.stream.Duplex, node.buffer.Buffer<*>>>

    @web.events.JsEvent("dropRequest")
    val dropRequestEvent: node.events.EventInstance<js.array.Tuple2<Request, node.stream.Duplex>>

    @web.events.JsEvent("request")
    open val requestEvent: node.events.EventInstance<js.array.Tuple2<Request, Response>>

    @web.events.JsEvent("upgrade")
    open val upgradeEvent:
            node.events.EventInstance<js.array.Tuple3<Request, node.stream.Duplex, node.buffer.Buffer<*>>>
}
