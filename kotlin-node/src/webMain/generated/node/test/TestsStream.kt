// Generated by Karakum - do not modify it manually!

@file:JsModule("node:test")

package node.test

import node.stream.Readable

/**
 * A successful call to `run()` will return a new `TestsStream` object, streaming a series of events representing the execution of the tests.
 *
 * Some of the events are guaranteed to be emitted in the same order as the tests are defined, while others are emitted in the order that the tests execute.
 * @since v18.9.0, v16.19.0
 */
external class TestsStream :
    Readable,
    node.ReadableStream {
    override fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun emit(
        event: String,
        vararg args: Any?,
    ): Boolean

    override fun emit(
        event: js.symbol.Symbol,
        vararg args: Any?,
    ): Boolean

    override fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    override fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

    @web.events.JsEvent("test:coverage")
    val testCoverageEvent: node.events.EventInstance<js.array.Tuple1<TestCoverage>>

    @web.events.JsEvent("test:complete")
    val testCompleteEvent: node.events.EventInstance<js.array.Tuple1<TestComplete>>

    @web.events.JsEvent("test:dequeue")
    val testDequeueEvent: node.events.EventInstance<js.array.Tuple1<TestDequeue>>

    @web.events.JsEvent("test:diagnostic")
    val testDiagnosticEvent: node.events.EventInstance<js.array.Tuple1<DiagnosticData>>

    @web.events.JsEvent("test:enqueue")
    val testEnqueueEvent: node.events.EventInstance<js.array.Tuple1<TestEnqueue>>

    @web.events.JsEvent("test:fail")
    val testFailEvent: node.events.EventInstance<js.array.Tuple1<TestFail>>

    @web.events.JsEvent("test:pass")
    val testPassEvent: node.events.EventInstance<js.array.Tuple1<TestPass>>

    @web.events.JsEvent("test:plan")
    val testPlanEvent: node.events.EventInstance<js.array.Tuple1<TestPlan>>

    @web.events.JsEvent("test:start")
    val testStartEvent: node.events.EventInstance<js.array.Tuple1<TestStart>>

    @web.events.JsEvent("test:stderr")
    val testStderrEvent: node.events.EventInstance<js.array.Tuple1<TestStderr>>

    @web.events.JsEvent("test:stdout")
    val testStdoutEvent: node.events.EventInstance<js.array.Tuple1<TestStdout>>

    @web.events.JsEvent("test:summary")
    val testSummaryEvent: node.events.EventInstance<js.array.Tuple1<TestSummary>>

    @web.events.JsEvent("test:watch:drained")
    val testWatchDrainedEvent: node.events.EventInstance<js.array.Tuple>
}
