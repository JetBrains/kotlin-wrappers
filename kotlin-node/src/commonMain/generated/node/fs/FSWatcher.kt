// Generated by Karakum - do not modify it manually!

package node.fs

import node.events.EventEmitter

@Suppress("INTERFACE_WITH_SUPERCLASS")
sealed external interface FSWatcher : EventEmitter {
    /**
     * Stop watching for changes on the given `fs.FSWatcher`. Once stopped, the `fs.FSWatcher` object is no longer usable.
     * @since v0.5.8
     */
    fun close(): Unit

    /**
     * When called, requests that the Node.js event loop _not_ exit so long as the `fs.FSWatcher` is active. Calling `watcher.ref()` multiple times will have
     * no effect.
     *
     * By default, all `fs.FSWatcher` objects are "ref'ed", making it normally
     * unnecessary to call `watcher.ref()` unless `watcher.unref()` had been
     * called previously.
     * @since v14.3.0, v12.20.0
     */
    fun ref(): Unit /* this */

    /**
     * When called, the active `fs.FSWatcher` object will not require the Node.js
     * event loop to remain active. If there is no other activity keeping the
     * event loop running, the process may exit before the `fs.FSWatcher` object's
     * callback is invoked. Calling `watcher.unref()` multiple times will have
     * no effect.
     * @since v14.3.0, v12.20.0
     */
    fun unref(): Unit /* this */

    /**
     * events.EventEmitter
     *   1. change
     *   2. close
     *   3. error
     */
    fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    @web.events.JsEvent("change")
    val changeEvent: node.events.EventInstance<js.array.JsTuple2<String, Any /* string | Buffer */>>

    @web.events.JsEvent("close")
    val closeEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("error")
    val errorEvent: node.events.EventInstance<js.array.JsTuple1<js.errors.JsError>>
}
