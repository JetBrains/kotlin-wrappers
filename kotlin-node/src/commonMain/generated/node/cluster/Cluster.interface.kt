// Generated by Karakum - do not modify it manually!

package node.cluster

import node.events.EventEmitter

@Suppress("INTERFACE_WITH_SUPERCLASS")
sealed external interface Cluster : EventEmitter {
    fun disconnect(callback: () -> Unit = definedExternally)

    /**
     * Spawn a new worker process.
     *
     * This can only be called from the primary process.
     * @param env Key/value pairs to add to worker process environment.
     * @since v0.6.0
     */
    fun fork(env: Any? = definedExternally): Worker

    /** @deprecated since v16.0.0 - use isPrimary. */
    val isMaster: Boolean

    /**
     * True if the process is a primary. This is determined by the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID`
     * is undefined, then `isPrimary` is `true`.
     * @since v16.0.0
     */
    val isPrimary: Boolean

    /**
     * True if the process is not a primary (it is the negation of `cluster.isPrimary`).
     * @since v0.6.0
     */
    val isWorker: Boolean

    /**
     * The scheduling policy, either `cluster.SCHED_RR` for round-robin or `cluster.SCHED_NONE` to leave it to the operating system. This is a
     * global setting and effectively frozen once either the first worker is spawned, or [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
     * is called, whichever comes first.
     *
     * `SCHED_RR` is the default on all operating systems except Windows. Windows will change to `SCHED_RR` once libuv is able to effectively distribute
     * IOCP handles without incurring a large performance hit.
     *
     * `cluster.schedulingPolicy` can also be set through the `NODE_CLUSTER_SCHED_POLICY` environment variable. Valid values are `'rr'` and `'none'`.
     * @since v0.11.2
     */
    var schedulingPolicy: Double

    /**
     * After calling [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings)
     * (or [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)) this settings object will contain
     * the settings, including the default values.
     *
     * This object is not intended to be changed or set manually.
     * @since v0.7.1
     */
    val settings: ClusterSettings

    /** @deprecated since v16.0.0 - use [`.setupPrimary()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clustersetupprimarysettings) instead. */
    fun setupMaster(settings: ClusterSettings = definedExternally)

    /**
     * `setupPrimary` is used to change the default 'fork' behavior. Once called, the settings will be present in `cluster.settings`.
     *
     * Any settings changes only affect future calls to [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv)
     * and have no effect on workers that are already running.
     *
     * The only attribute of a worker that cannot be set via `.setupPrimary()` is the `env` passed to
     * [`.fork()`](https://nodejs.org/docs/latest-v22.x/api/cluster.html#clusterforkenv).
     *
     * The defaults above apply to the first call only; the defaults for later calls are the current values at the time of
     * `cluster.setupPrimary()` is called.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * cluster.setupPrimary({
     *   exec: 'worker.js',
     *   args: ['--use', 'https'],
     *   silent: true,
     * });
     * cluster.fork(); // https worker
     * cluster.setupPrimary({
     *   exec: 'worker.js',
     *   args: ['--use', 'http'],
     * });
     * cluster.fork(); // http worker
     * ```
     *
     * This can only be called from the primary process.
     * @since v16.0.0
     */
    fun setupPrimary(settings: ClusterSettings = definedExternally)

    /**
     * A reference to the current worker object. Not available in the primary process.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * if (cluster.isPrimary) {
     *   console.log('I am primary');
     *   cluster.fork();
     *   cluster.fork();
     * } else if (cluster.isWorker) {
     *   console.log(`I am worker #${cluster.worker.id}`);
     * }
     * ```
     * @since v0.7.0
     */
    val worker: Worker?

    /**
     * A hash that stores the active worker objects, keyed by `id` field. This makes it easy to loop through all the workers. It is only available in the primary process.
     *
     * A worker is removed from `cluster.workers` after the worker has disconnected _and_ exited. The order between these two events cannot be determined in advance. However, it
     * is guaranteed that the removal from the `cluster.workers` list happens before the last `'disconnect'` or `'exit'` event is emitted.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * for (const worker of Object.values(cluster.workers)) {
     *   worker.send('big announcement to all workers');
     * }
     * ```
     * @since v0.7.0
     */
    val workers: node.Dict<Worker>?
    val SCHED_NONE: Double
    val SCHED_RR: Double

    /**
     * events.EventEmitter
     *   1. disconnect
     *   2. exit
     *   3. fork
     *   4. listening
     *   5. message
     *   6. online
     *   7. setup
     */
    fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

// the handle is a net.Socket or net.Server object, or undefined.

    fun emit(
        event: String,
        vararg args: Any?,
    ): Boolean

    fun emit(
        event: js.symbol.Symbol,
        vararg args: Any?,
    ): Boolean

    fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

// the handle is a net.Socket or net.Server object, or undefined.

    fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

// the handle is a net.Socket or net.Server object, or undefined.

    fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

// the handle is a net.Socket or net.Server object, or undefined.

    fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */) // this

// the handle is a net.Socket or net.Server object, or undefined.

    @web.events.JsEvent("disconnect")
    val disconnectEvent: node.events.EventInstance<js.array.Tuple1<Worker>>

    @web.events.JsEvent("exit")
    val exitEvent: node.events.EventInstance<js.array.Tuple3<Worker, Double, String>>

    @web.events.JsEvent("fork")
    val forkEvent: node.events.EventInstance<js.array.Tuple1<Worker>>

    @web.events.JsEvent("listening")
    val listeningEvent: node.events.EventInstance<js.array.Tuple2<Worker, Address>>

    @web.events.JsEvent("message")
    val messageEvent: node.events.EventInstance<js.array.Tuple3<Worker, Any?, Any /* net.Socket | net.Server */>>

    @web.events.JsEvent("online")
    val onlineEvent: node.events.EventInstance<js.array.Tuple1<Worker>>

    @web.events.JsEvent("setup")
    val setupEvent: node.events.EventInstance<js.array.Tuple1<ClusterSettings>>
}
