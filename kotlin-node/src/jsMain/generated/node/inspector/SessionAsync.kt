// Generated by Karakum - do not modify it manually!

@file:JsModule("node:inspector/promises")

package node.inspector

import js.promise.Promise
import node.events.EventEmitter

/**
 * The `inspector.Session` is used for dispatching messages to the V8 inspector
 * back-end and receiving message responses and notifications.
 * @since v19.0.0
 */
external class Session : EventEmitter {
    /**
     * Create a new instance of the `inspector.Session` class.
     * The inspector session needs to be connected through `session.connect()` before the messages can be dispatched to the inspector backend.
     */
    constructor ()

    /**
     * Connects a session to the inspector back-end.
     */
    fun connect(): Unit

    /**
     * Connects a session to the inspector back-end.
     * An exception will be thrown if this API was not called on a Worker thread.
     */
    fun connectToMainThread(): Unit

    /**
     * Immediately close the session. All pending message callbacks will be called with an error.
     * `session.connect()` will need to be called to be able to send messages again.
     * Reconnected session will lose all inspector state, such as enabled agents or configured breakpoints.
     */
    fun disconnect(): Unit

    /**
     * Posts a message to the inspector back-end.
     *
     * ```js
     * import { Session } from 'node:inspector/promises';
     * try {
     *   const session = new Session();
     *   session.connect();
     *   const result = await session.post('Runtime.evaluate', { expression: '2 + 2' });
     *   console.log(result);
     * } catch (error) {
     *   console.error(error);
     * }
     * // Output: { result: { type: 'number', value: 4, description: '4' } }
     * ```
     *
     * The latest version of the V8 inspector protocol is published on the
     * [Chrome DevTools Protocol Viewer](https://chromedevtools.github.io/devtools-protocol/v8/).
     *
     * Node.js inspector supports all the Chrome DevTools Protocol domains declared
     * by V8. Chrome DevTools Protocol domain provides an interface for interacting
     * with one of the runtime agents used to inspect the application state and listen
     * to the run-time events.
     */
    fun post(method: String, params: Any = definedExternally): Promise<js.core.Void>

    /**
     * Returns supported domains.
     */
    fun post(method: SessionMethod.SCHEMA_GETDOMAINS): Promise<node.inspector.schema.GetDomainsReturnType>

    /**
     * Evaluates expression on global object.
     */
    fun post(
        method: SessionMethod.RUNTIME_EVALUATE,
        params: node.inspector.runtime.EvaluateParameterType = definedExternally,
    ): Promise<node.inspector.runtime.EvaluateReturnType>

    /**
     * Add handler to promise with given promise object id.
     */
    fun post(
        method: SessionMethod.RUNTIME_AWAITPROMISE,
        params: node.inspector.runtime.AwaitPromiseParameterType = definedExternally,
    ): Promise<node.inspector.runtime.AwaitPromiseReturnType>

    /**
     * Calls function with given declaration on the given object. Object group of the result is inherited from the target object.
     */
    fun post(
        method: SessionMethod.RUNTIME_CALLFUNCTIONON,
        params: node.inspector.runtime.CallFunctionOnParameterType = definedExternally,
    ): Promise<node.inspector.runtime.CallFunctionOnReturnType>

    /**
     * Returns properties of a given object. Object group of the result is inherited from the target object.
     */
    fun post(
        method: SessionMethod.RUNTIME_GETPROPERTIES,
        params: node.inspector.runtime.GetPropertiesParameterType = definedExternally,
    ): Promise<node.inspector.runtime.GetPropertiesReturnType>

    /**
     * Releases remote object with given id.
     */
    fun post(
        method: SessionMethod.RUNTIME_RELEASEOBJECT,
        params: node.inspector.runtime.ReleaseObjectParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Releases all remote objects that belong to a given group.
     */
    fun post(
        method: SessionMethod.RUNTIME_RELEASEOBJECTGROUP,
        params: node.inspector.runtime.ReleaseObjectGroupParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Tells inspected instance to run if it was waiting for debugger to attach.
     */
    fun post(method: SessionMethod.RUNTIME_RUNIFWAITINGFORDEBUGGER): Promise<js.core.Void>

    /**
     * Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context.
     */
    fun post(method: SessionMethod.RUNTIME_ENABLE): Promise<js.core.Void>

    /**
     * Disables reporting of execution contexts creation.
     */
    fun post(method: SessionMethod.RUNTIME_DISABLE): Promise<js.core.Void>

    /**
     * Discards collected exceptions and console API calls.
     */
    fun post(method: SessionMethod.RUNTIME_DISCARDCONSOLEENTRIES): Promise<js.core.Void>

    /**
     * @experimental
     */
    fun post(
        method: SessionMethod.RUNTIME_SETCUSTOMOBJECTFORMATTERENABLED,
        params: node.inspector.runtime.SetCustomObjectFormatterEnabledParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Compiles expression.
     */
    fun post(
        method: SessionMethod.RUNTIME_COMPILESCRIPT,
        params: node.inspector.runtime.CompileScriptParameterType = definedExternally,
    ): Promise<node.inspector.runtime.CompileScriptReturnType>

    /**
     * Runs script with given id in a given context.
     */
    fun post(
        method: SessionMethod.RUNTIME_RUNSCRIPT,
        params: node.inspector.runtime.RunScriptParameterType = definedExternally,
    ): Promise<node.inspector.runtime.RunScriptReturnType>

    fun post(
        method: SessionMethod.RUNTIME_QUERYOBJECTS,
        params: node.inspector.runtime.QueryObjectsParameterType = definedExternally,
    ): Promise<node.inspector.runtime.QueryObjectsReturnType>

    /**
     * Returns all let, const and class variables from global scope.
     */
    fun post(
        method: SessionMethod.RUNTIME_GLOBALLEXICALSCOPENAMES,
        params: node.inspector.runtime.GlobalLexicalScopeNamesParameterType = definedExternally,
    ): Promise<node.inspector.runtime.GlobalLexicalScopeNamesReturnType>

    /**
     * Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received.
     */
    fun post(method: SessionMethod.DEBUGGER_ENABLE): Promise<node.inspector.debugger.EnableReturnType>

    /**
     * Disables debugger for given page.
     */
    fun post(method: SessionMethod.DEBUGGER_DISABLE): Promise<js.core.Void>

    /**
     * Activates / deactivates all breakpoints on the page.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETBREAKPOINTSACTIVE,
        params: node.inspector.debugger.SetBreakpointsActiveParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Makes page not interrupt on any pauses (breakpoint, exception, dom exception etc).
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETSKIPALLPAUSES,
        params: node.inspector.debugger.SetSkipAllPausesParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETBREAKPOINTBYURL,
        params: node.inspector.debugger.SetBreakpointByUrlParameterType = definedExternally,
    ): Promise<node.inspector.debugger.SetBreakpointByUrlReturnType>

    /**
     * Sets JavaScript breakpoint at a given location.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETBREAKPOINT,
        params: node.inspector.debugger.SetBreakpointParameterType = definedExternally,
    ): Promise<node.inspector.debugger.SetBreakpointReturnType>

    /**
     * Removes JavaScript breakpoint.
     */
    fun post(
        method: SessionMethod.DEBUGGER_REMOVEBREAKPOINT,
        params: node.inspector.debugger.RemoveBreakpointParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Returns possible locations for breakpoint. scriptId in start and end range locations should be the same.
     */
    fun post(
        method: SessionMethod.DEBUGGER_GETPOSSIBLEBREAKPOINTS,
        params: node.inspector.debugger.GetPossibleBreakpointsParameterType = definedExternally,
    ): Promise<node.inspector.debugger.GetPossibleBreakpointsReturnType>

    /**
     * Continues execution until specific location is reached.
     */
    fun post(
        method: SessionMethod.DEBUGGER_CONTINUETOLOCATION,
        params: node.inspector.debugger.ContinueToLocationParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * @experimental
     */
    fun post(
        method: SessionMethod.DEBUGGER_PAUSEONASYNCCALL,
        params: node.inspector.debugger.PauseOnAsyncCallParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Steps over the statement.
     */
    fun post(method: SessionMethod.DEBUGGER_STEPOVER): Promise<js.core.Void>

    /**
     * Steps into the function call.
     */
    fun post(
        method: SessionMethod.DEBUGGER_STEPINTO,
        params: node.inspector.debugger.StepIntoParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Steps out of the function call.
     */
    fun post(method: SessionMethod.DEBUGGER_STEPOUT): Promise<js.core.Void>

    /**
     * Stops on the next JavaScript statement.
     */
    fun post(method: SessionMethod.DEBUGGER_PAUSE): Promise<js.core.Void>

    /**
     * This method is deprecated - use Debugger.stepInto with breakOnAsyncCall and Debugger.pauseOnAsyncTask instead. Steps into next scheduled async task if any is scheduled before next pause. Returns success when async task is actually scheduled, returns error if no task were scheduled or another scheduleStepIntoAsync was called.
     * @experimental
     */
    fun post(method: SessionMethod.DEBUGGER_SCHEDULESTEPINTOASYNC): Promise<js.core.Void>

    /**
     * Resumes JavaScript execution.
     */
    fun post(method: SessionMethod.DEBUGGER_RESUME): Promise<js.core.Void>

    /**
     * Returns stack trace with given <code>stackTraceId</code>.
     * @experimental
     */
    fun post(
        method: SessionMethod.DEBUGGER_GETSTACKTRACE,
        params: node.inspector.debugger.GetStackTraceParameterType = definedExternally,
    ): Promise<node.inspector.debugger.GetStackTraceReturnType>

    /**
     * Searches for given string in script content.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SEARCHINCONTENT,
        params: node.inspector.debugger.SearchInContentParameterType = definedExternally,
    ): Promise<node.inspector.debugger.SearchInContentReturnType>

    /**
     * Edits JavaScript source live.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETSCRIPTSOURCE,
        params: node.inspector.debugger.SetScriptSourceParameterType = definedExternally,
    ): Promise<node.inspector.debugger.SetScriptSourceReturnType>

    /**
     * Restarts particular call frame from the beginning.
     */
    fun post(
        method: SessionMethod.DEBUGGER_RESTARTFRAME,
        params: node.inspector.debugger.RestartFrameParameterType = definedExternally,
    ): Promise<node.inspector.debugger.RestartFrameReturnType>

    /**
     * Returns source for the script with given id.
     */
    fun post(
        method: SessionMethod.DEBUGGER_GETSCRIPTSOURCE,
        params: node.inspector.debugger.GetScriptSourceParameterType = definedExternally,
    ): Promise<node.inspector.debugger.GetScriptSourceReturnType>

    /**
     * Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETPAUSEONEXCEPTIONS,
        params: node.inspector.debugger.SetPauseOnExceptionsParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Evaluates expression on a given call frame.
     */
    fun post(
        method: SessionMethod.DEBUGGER_EVALUATEONCALLFRAME,
        params: node.inspector.debugger.EvaluateOnCallFrameParameterType = definedExternally,
    ): Promise<node.inspector.debugger.EvaluateOnCallFrameReturnType>

    /**
     * Changes value of variable in a callframe. Object-based scopes are not supported and must be mutated manually.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETVARIABLEVALUE,
        params: node.inspector.debugger.SetVariableValueParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Changes return value in top frame. Available only at return break position.
     * @experimental
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETRETURNVALUE,
        params: node.inspector.debugger.SetReturnValueParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Enables or disables async call stacks tracking.
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETASYNCCALLSTACKDEPTH,
        params: node.inspector.debugger.SetAsyncCallStackDepthParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Replace previous blackbox patterns with passed ones. Forces backend to skip stepping/pausing in scripts with url matching one of the patterns. VM will try to leave blackboxed script by performing 'step in' several times, finally resorting to 'step out' if unsuccessful.
     * @experimental
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETBLACKBOXPATTERNS,
        params: node.inspector.debugger.SetBlackboxPatternsParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Makes backend skip steps in the script in blackboxed ranges. VM will try leave blacklisted scripts by performing 'step in' several times, finally resorting to 'step out' if unsuccessful. Positions array contains positions where blackbox state is changed. First interval isn't blackboxed. Array should be sorted.
     * @experimental
     */
    fun post(
        method: SessionMethod.DEBUGGER_SETBLACKBOXEDRANGES,
        params: node.inspector.debugger.SetBlackboxedRangesParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification.
     */
    fun post(method: SessionMethod.CONSOLE_ENABLE): Promise<js.core.Void>

    /**
     * Disables console domain, prevents further console messages from being reported to the client.
     */
    fun post(method: SessionMethod.CONSOLE_DISABLE): Promise<js.core.Void>

    /**
     * Does nothing.
     */
    fun post(method: SessionMethod.CONSOLE_CLEARMESSAGES): Promise<js.core.Void>
    fun post(method: SessionMethod.PROFILER_ENABLE): Promise<js.core.Void>
    fun post(method: SessionMethod.PROFILER_DISABLE): Promise<js.core.Void>

    /**
     * Changes CPU profiler sampling interval. Must be called before CPU profiles recording started.
     */
    fun post(
        method: SessionMethod.PROFILER_SETSAMPLINGINTERVAL,
        params: node.inspector.profiler.SetSamplingIntervalParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(method: SessionMethod.PROFILER_START): Promise<js.core.Void>
    fun post(method: SessionMethod.PROFILER_STOP): Promise<node.inspector.profiler.StopReturnType>

    /**
     * Enable precise code coverage. Coverage data for JavaScript executed before enabling precise code coverage may be incomplete. Enabling prevents running optimized code and resets execution counters.
     */
    fun post(
        method: SessionMethod.PROFILER_STARTPRECISECOVERAGE,
        params: node.inspector.profiler.StartPreciseCoverageParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Disable precise code coverage. Disabling releases unnecessary execution count records and allows executing optimized code.
     */
    fun post(method: SessionMethod.PROFILER_STOPPRECISECOVERAGE): Promise<js.core.Void>

    /**
     * Collect coverage data for the current isolate, and resets execution counters. Precise code coverage needs to have started.
     */
    fun post(method: SessionMethod.PROFILER_TAKEPRECISECOVERAGE): Promise<node.inspector.profiler.TakePreciseCoverageReturnType>

    /**
     * Collect coverage data for the current isolate. The coverage data may be incomplete due to garbage collection.
     */
    fun post(method: SessionMethod.PROFILER_GETBESTEFFORTCOVERAGE): Promise<node.inspector.profiler.GetBestEffortCoverageReturnType>
    fun post(method: SessionMethod.HEAPPROFILER_ENABLE): Promise<js.core.Void>
    fun post(method: SessionMethod.HEAPPROFILER_DISABLE): Promise<js.core.Void>
    fun post(
        method: SessionMethod.HEAPPROFILER_STARTTRACKINGHEAPOBJECTS,
        params: node.inspector.heapprofiler.StartTrackingHeapObjectsParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(
        method: SessionMethod.HEAPPROFILER_STOPTRACKINGHEAPOBJECTS,
        params: node.inspector.heapprofiler.StopTrackingHeapObjectsParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(
        method: SessionMethod.HEAPPROFILER_TAKEHEAPSNAPSHOT,
        params: node.inspector.heapprofiler.TakeHeapSnapshotParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(method: SessionMethod.HEAPPROFILER_COLLECTGARBAGE): Promise<js.core.Void>
    fun post(
        method: SessionMethod.HEAPPROFILER_GETOBJECTBYHEAPOBJECTID,
        params: node.inspector.heapprofiler.GetObjectByHeapObjectIdParameterType = definedExternally,
    ): Promise<node.inspector.heapprofiler.GetObjectByHeapObjectIdReturnType>

    /**
     * Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).
     */
    fun post(
        method: SessionMethod.HEAPPROFILER_ADDINSPECTEDHEAPOBJECT,
        params: node.inspector.heapprofiler.AddInspectedHeapObjectParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(
        method: SessionMethod.HEAPPROFILER_GETHEAPOBJECTID,
        params: node.inspector.heapprofiler.GetHeapObjectIdParameterType = definedExternally,
    ): Promise<node.inspector.heapprofiler.GetHeapObjectIdReturnType>

    fun post(
        method: SessionMethod.HEAPPROFILER_STARTSAMPLING,
        params: node.inspector.heapprofiler.StartSamplingParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun post(method: SessionMethod.HEAPPROFILER_STOPSAMPLING): Promise<node.inspector.heapprofiler.StopSamplingReturnType>
    fun post(method: SessionMethod.HEAPPROFILER_GETSAMPLINGPROFILE): Promise<node.inspector.heapprofiler.GetSamplingProfileReturnType>

    /**
     * Gets supported tracing categories.
     */
    fun post(method: SessionMethod.NODETRACING_GETCATEGORIES): Promise<node.inspector.nodetracing.GetCategoriesReturnType>

    /**
     * Start trace events collection.
     */
    fun post(
        method: SessionMethod.NODETRACING_START,
        params: node.inspector.nodetracing.StartParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Stop trace events collection. Remaining collected events will be sent as a sequence of
     * dataCollected events followed by tracingComplete event.
     */
    fun post(method: SessionMethod.NODETRACING_STOP): Promise<js.core.Void>

    /**
     * Sends protocol message over session with given id.
     */
    fun post(
        method: SessionMethod.NODEWORKER_SENDMESSAGETOWORKER,
        params: node.inspector.nodeworker.SendMessageToWorkerParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Instructs the inspector to attach to running workers. Will also attach to new workers
     * as they start
     */
    fun post(
        method: SessionMethod.NODEWORKER_ENABLE,
        params: node.inspector.nodeworker.EnableParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Detaches from all running workers and disables attaching to new workers as they are started.
     */
    fun post(method: SessionMethod.NODEWORKER_DISABLE): Promise<js.core.Void>

    /**
     * Detached from the worker with given sessionId.
     */
    fun post(
        method: SessionMethod.NODEWORKER_DETACH,
        params: node.inspector.nodeworker.DetachParameterType = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Enable the NodeRuntime events except by `NodeRuntime.waitingForDisconnect`.
     */
    fun post(method: SessionMethod.NODERUNTIME_ENABLE): Promise<js.core.Void>

    /**
     * Disable NodeRuntime events
     */
    fun post(method: SessionMethod.NODERUNTIME_DISABLE): Promise<js.core.Void>

    /**
     * Enable the `NodeRuntime.waitingForDisconnect`.
     */
    fun post(
        method: SessionMethod.NODERUNTIME_NOTIFYWHENWAITINGFORDISCONNECT,
        params: node.inspector.noderuntime.NotifyWhenWaitingForDisconnectParameterType = definedExternally,
    ): Promise<js.core.Void>

    fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    /**
     * Emitted when any notification from the V8 Inspector is received.
     */

    /**
     * Issued when new execution context is created.
     */

    /**
     * Issued when execution context is destroyed.
     */

    /**
     * Issued when all executionContexts were cleared in browser
     */

    /**
     * Issued when exception was thrown and unhandled.
     */

    /**
     * Issued when unhandled exception was revoked.
     */

    /**
     * Issued when console API was called.
     */

    /**
     * Issued when object should be inspected (for example, as a result of inspect() command line API call).
     */

    /**
     * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
     */

    /**
     * Fired when virtual machine fails to parse the script.
     */

    /**
     * Fired when breakpoint is resolved to an actual script and location.
     */

    /**
     * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
     */

    /**
     * Fired when the virtual machine resumed execution.
     */

    /**
     * Issued when new console message is added.
     */

    /**
     * Sent when new profile recording is started using console.profile() call.
     */


    /**
     * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
     */

    /**
     * If heap objects tracking has been started then backend may send update for one or more fragments
     */

    /**
     * Contains an bucket of collected trace events.
     */

    /**
     * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
     * delivered via dataCollected events.
     */

    /**
     * Issued when attached to a worker.
     */

    /**
     * Issued when detached from the worker.
     */

    /**
     * Notifies about a new protocol message received from the session
     * (session ID is provided in attachedToWorker notification).
     */

    /**
     * This event is fired instead of `Runtime.executionContextDestroyed` when
     * enabled.
     * It is fired when the Node process finished all code execution and is
     * waiting for all frontends to disconnect.
     */

    /**
     * This event is fired when the runtime is waiting for the debugger. For
     * example, when inspector.waitingForDebugger is called
     */

    fun emit(event: String, vararg args: Any?): Boolean

    fun emit(event: js.symbol.Symbol, vararg args: Any?): Boolean


    fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    /**
     * Emitted when any notification from the V8 Inspector is received.
     */

    /**
     * Issued when new execution context is created.
     */

    /**
     * Issued when execution context is destroyed.
     */

    /**
     * Issued when all executionContexts were cleared in browser
     */

    /**
     * Issued when exception was thrown and unhandled.
     */

    /**
     * Issued when unhandled exception was revoked.
     */

    /**
     * Issued when console API was called.
     */

    /**
     * Issued when object should be inspected (for example, as a result of inspect() command line API call).
     */

    /**
     * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
     */

    /**
     * Fired when virtual machine fails to parse the script.
     */

    /**
     * Fired when breakpoint is resolved to an actual script and location.
     */

    /**
     * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
     */

    /**
     * Fired when the virtual machine resumed execution.
     */

    /**
     * Issued when new console message is added.
     */

    /**
     * Sent when new profile recording is started using console.profile() call.
     */


    /**
     * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
     */

    /**
     * If heap objects tracking has been started then backend may send update for one or more fragments
     */

    /**
     * Contains an bucket of collected trace events.
     */

    /**
     * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
     * delivered via dataCollected events.
     */

    /**
     * Issued when attached to a worker.
     */

    /**
     * Issued when detached from the worker.
     */

    /**
     * Notifies about a new protocol message received from the session
     * (session ID is provided in attachedToWorker notification).
     */

    /**
     * This event is fired instead of `Runtime.executionContextDestroyed` when
     * enabled.
     * It is fired when the Node process finished all code execution and is
     * waiting for all frontends to disconnect.
     */

    /**
     * This event is fired when the runtime is waiting for the debugger. For
     * example, when inspector.waitingForDebugger is called
     */

    fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    /**
     * Emitted when any notification from the V8 Inspector is received.
     */

    /**
     * Issued when new execution context is created.
     */

    /**
     * Issued when execution context is destroyed.
     */

    /**
     * Issued when all executionContexts were cleared in browser
     */

    /**
     * Issued when exception was thrown and unhandled.
     */

    /**
     * Issued when unhandled exception was revoked.
     */

    /**
     * Issued when console API was called.
     */

    /**
     * Issued when object should be inspected (for example, as a result of inspect() command line API call).
     */

    /**
     * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
     */

    /**
     * Fired when virtual machine fails to parse the script.
     */

    /**
     * Fired when breakpoint is resolved to an actual script and location.
     */

    /**
     * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
     */

    /**
     * Fired when the virtual machine resumed execution.
     */

    /**
     * Issued when new console message is added.
     */

    /**
     * Sent when new profile recording is started using console.profile() call.
     */


    /**
     * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
     */

    /**
     * If heap objects tracking has been started then backend may send update for one or more fragments
     */

    /**
     * Contains an bucket of collected trace events.
     */

    /**
     * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
     * delivered via dataCollected events.
     */

    /**
     * Issued when attached to a worker.
     */

    /**
     * Issued when detached from the worker.
     */

    /**
     * Notifies about a new protocol message received from the session
     * (session ID is provided in attachedToWorker notification).
     */

    /**
     * This event is fired instead of `Runtime.executionContextDestroyed` when
     * enabled.
     * It is fired when the Node process finished all code execution and is
     * waiting for all frontends to disconnect.
     */

    /**
     * This event is fired when the runtime is waiting for the debugger. For
     * example, when inspector.waitingForDebugger is called
     */

    fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    /**
     * Emitted when any notification from the V8 Inspector is received.
     */

    /**
     * Issued when new execution context is created.
     */

    /**
     * Issued when execution context is destroyed.
     */

    /**
     * Issued when all executionContexts were cleared in browser
     */

    /**
     * Issued when exception was thrown and unhandled.
     */

    /**
     * Issued when unhandled exception was revoked.
     */

    /**
     * Issued when console API was called.
     */

    /**
     * Issued when object should be inspected (for example, as a result of inspect() command line API call).
     */

    /**
     * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
     */

    /**
     * Fired when virtual machine fails to parse the script.
     */

    /**
     * Fired when breakpoint is resolved to an actual script and location.
     */

    /**
     * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
     */

    /**
     * Fired when the virtual machine resumed execution.
     */

    /**
     * Issued when new console message is added.
     */

    /**
     * Sent when new profile recording is started using console.profile() call.
     */


    /**
     * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
     */

    /**
     * If heap objects tracking has been started then backend may send update for one or more fragments
     */

    /**
     * Contains an bucket of collected trace events.
     */

    /**
     * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
     * delivered via dataCollected events.
     */

    /**
     * Issued when attached to a worker.
     */

    /**
     * Issued when detached from the worker.
     */

    /**
     * Notifies about a new protocol message received from the session
     * (session ID is provided in attachedToWorker notification).
     */

    /**
     * This event is fired instead of `Runtime.executionContextDestroyed` when
     * enabled.
     * It is fired when the Node process finished all code execution and is
     * waiting for all frontends to disconnect.
     */

    /**
     * This event is fired when the runtime is waiting for the debugger. For
     * example, when inspector.waitingForDebugger is called
     */

    fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    /**
     * Emitted when any notification from the V8 Inspector is received.
     */

    /**
     * Issued when new execution context is created.
     */

    /**
     * Issued when execution context is destroyed.
     */

    /**
     * Issued when all executionContexts were cleared in browser
     */

    /**
     * Issued when exception was thrown and unhandled.
     */

    /**
     * Issued when unhandled exception was revoked.
     */

    /**
     * Issued when console API was called.
     */

    /**
     * Issued when object should be inspected (for example, as a result of inspect() command line API call).
     */

    /**
     * Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger.
     */

    /**
     * Fired when virtual machine fails to parse the script.
     */

    /**
     * Fired when breakpoint is resolved to an actual script and location.
     */

    /**
     * Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria.
     */

    /**
     * Fired when the virtual machine resumed execution.
     */

    /**
     * Issued when new console message is added.
     */

    /**
     * Sent when new profile recording is started using console.profile() call.
     */


    /**
     * If heap objects tracking has been started then backend regularly sends a current value for last seen object id and corresponding timestamp. If the were changes in the heap since last event then one or more heapStatsUpdate events will be sent before a new lastSeenObjectId event.
     */

    /**
     * If heap objects tracking has been started then backend may send update for one or more fragments
     */

    /**
     * Contains an bucket of collected trace events.
     */

    /**
     * Signals that tracing is stopped and there is no trace buffers pending flush, all data were
     * delivered via dataCollected events.
     */

    /**
     * Issued when attached to a worker.
     */

    /**
     * Issued when detached from the worker.
     */

    /**
     * Notifies about a new protocol message received from the session
     * (session ID is provided in attachedToWorker notification).
     */

    /**
     * This event is fired instead of `Runtime.executionContextDestroyed` when
     * enabled.
     * It is fired when the Node process finished all code execution and is
     * waiting for all frontends to disconnect.
     */

    /**
     * This event is fired when the runtime is waiting for the debugger. For
     * example, when inspector.waitingForDebugger is called
     */

    @web.events.JsEvent("inspectorNotification")
    val inspectorNotificationEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<Any>>>

    @web.events.JsEvent("Runtime.executionContextCreated")
    val RuntimeExecutionContextCreatedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.ExecutionContextCreatedEventDataType>>>

    @web.events.JsEvent("Runtime.executionContextDestroyed")
    val RuntimeExecutionContextDestroyedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.ExecutionContextDestroyedEventDataType>>>

    @web.events.JsEvent("Runtime.executionContextsCleared")
    val RuntimeExecutionContextsClearedEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("Runtime.exceptionThrown")
    val RuntimeExceptionThrownEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.ExceptionThrownEventDataType>>>

    @web.events.JsEvent("Runtime.exceptionRevoked")
    val RuntimeExceptionRevokedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.ExceptionRevokedEventDataType>>>

    @web.events.JsEvent("Runtime.consoleAPICalled")
    val RuntimeConsoleAPICalledEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.ConsoleAPICalledEventDataType>>>

    @web.events.JsEvent("Runtime.inspectRequested")
    val RuntimeInspectRequestedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.runtime.InspectRequestedEventDataType>>>

    @web.events.JsEvent("Debugger.scriptParsed")
    val DebuggerScriptParsedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.debugger.ScriptParsedEventDataType>>>

    @web.events.JsEvent("Debugger.scriptFailedToParse")
    val DebuggerScriptFailedToParseEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.debugger.ScriptFailedToParseEventDataType>>>

    @web.events.JsEvent("Debugger.breakpointResolved")
    val DebuggerBreakpointResolvedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.debugger.BreakpointResolvedEventDataType>>>

    @web.events.JsEvent("Debugger.paused")
    val DebuggerPausedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.debugger.PausedEventDataType>>>

    @web.events.JsEvent("Debugger.resumed")
    val DebuggerResumedEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("Console.messageAdded")
    val ConsoleMessageAddedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.console.MessageAddedEventDataType>>>

    @web.events.JsEvent("Profiler.consoleProfileStarted")
    val ProfilerConsoleProfileStartedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.profiler.ConsoleProfileStartedEventDataType>>>

    @web.events.JsEvent("Profiler.consoleProfileFinished")
    val ProfilerConsoleProfileFinishedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.profiler.ConsoleProfileFinishedEventDataType>>>

    @web.events.JsEvent("HeapProfiler.addHeapSnapshotChunk")
    val HeapProfilerAddHeapSnapshotChunkEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.heapprofiler.AddHeapSnapshotChunkEventDataType>>>

    @web.events.JsEvent("HeapProfiler.resetProfiles")
    val HeapProfilerResetProfilesEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("HeapProfiler.reportHeapSnapshotProgress")
    val HeapProfilerReportHeapSnapshotProgressEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.heapprofiler.ReportHeapSnapshotProgressEventDataType>>>

    @web.events.JsEvent("HeapProfiler.lastSeenObjectId")
    val HeapProfilerLastSeenObjectIdEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.heapprofiler.LastSeenObjectIdEventDataType>>>

    @web.events.JsEvent("HeapProfiler.heapStatsUpdate")
    val HeapProfilerHeapStatsUpdateEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.heapprofiler.HeapStatsUpdateEventDataType>>>

    @web.events.JsEvent("NodeTracing.dataCollected")
    val NodeTracingDataCollectedEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.nodetracing.DataCollectedEventDataType>>>

    @web.events.JsEvent("NodeTracing.tracingComplete")
    val NodeTracingTracingCompleteEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("NodeWorker.attachedToWorker")
    val NodeWorkerAttachedToWorkerEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.nodeworker.AttachedToWorkerEventDataType>>>

    @web.events.JsEvent("NodeWorker.detachedFromWorker")
    val NodeWorkerDetachedFromWorkerEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.nodeworker.DetachedFromWorkerEventDataType>>>

    @web.events.JsEvent("NodeWorker.receivedMessageFromWorker")
    val NodeWorkerReceivedMessageFromWorkerEvent: node.events.EventInstance<js.array.JsTuple1<InspectorNotification<node.inspector.nodeworker.ReceivedMessageFromWorkerEventDataType>>>

    @web.events.JsEvent("NodeRuntime.waitingForDisconnect")
    val NodeRuntimeWaitingForDisconnectEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("NodeRuntime.waitingForDebugger")
    val NodeRuntimeWaitingForDebuggerEvent: node.events.EventInstance<js.array.JsTuple>
}
