// Generated by Karakum - do not modify it manually!

@file:JsModule("node:https")

package node.https

import node.http.IncomingMessage
import node.http.ServerResponse
import node.stream.Duplex


/**
 * See `http.Server` for more information.
 * @since v0.3.4
 */
@Suppress("MANY_CLASSES_IN_SUPERTYPE_LIST")
external class Server<Request : IncomingMessage, Response : ServerResponse<*>> : node.tls.Server, @seskar.js.JsMixin
node.http.Server<Request, Response> {
    constructor (requestListener: node.http.RequestListener<Request, Response> = definedExternally)
    constructor (
        options: ServerOptions<Request, Response>,
        requestListener: node.http.RequestListener<Request, Response> = definedExternally,
    )

    /**
     * Closes all connections connected to this server.
     * @since v18.2.0
     */
    override fun closeAllConnections(): Unit

    /**
     * Closes all connections connected to this server which are not sending a request or waiting for a response.
     * @since v18.2.0
     */
    override fun closeIdleConnections(): Unit
    override fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    override fun emit(event: String, vararg args: Any?): Boolean


    override fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    override fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    override fun prependListener(
        event: String,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */


    override fun prependOnceListener(
        event: String,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */


    @web.events.JsEvent("keylog")
    override val keylogEvent: node.events.EventInstance<js.array.JsTuple2<node.buffer.Buffer, node.tls.TLSSocket>>

    @web.events.JsEvent("OCSPRequest")
    override val OCSPRequestEvent: node.events.EventInstance<js.array.JsTuple3<node.buffer.Buffer, node.buffer.Buffer, (err: js.errors.JsError?, resp: node.buffer.Buffer) -> Unit>>

    @web.events.JsEvent("secureConnection")
    override val secureConnectionEvent: node.events.EventInstance<js.array.JsTuple1<node.tls.TLSSocket>>

    @web.events.JsEvent("tlsClientError")
    override val tlsClientErrorEvent: node.events.EventInstance<js.array.JsTuple2<js.errors.JsError, node.tls.TLSSocket>>

    @web.events.JsEvent("close")
    override val closeEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("error")
    override val errorEvent: node.events.EventInstance<js.array.JsTuple1<js.errors.JsError>>

    @web.events.JsEvent("listening")
    override val listeningEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("checkContinue")
    override val checkContinueEvent: node.events.EventInstance<js.array.JsTuple2<Request, Response>>

    @web.events.JsEvent("checkExpectation")
    override val checkExpectationEvent: node.events.EventInstance<js.array.JsTuple2<Request, Response>>

    @web.events.JsEvent("clientError")
    override val clientErrorEvent: node.events.EventInstance<js.array.JsTuple2<js.errors.JsError, Duplex>>

    @web.events.JsEvent("connect")
    override val connectEvent: node.events.EventInstance<js.array.JsTuple3<Request, Duplex, node.buffer.Buffer>>

    @web.events.JsEvent("request")
    override val requestEvent: node.events.EventInstance<js.array.JsTuple2<Request, Response>>

    @web.events.JsEvent("upgrade")
    override val upgradeEvent: node.events.EventInstance<js.array.JsTuple3<Request, Duplex, node.buffer.Buffer>>
}
