// Generated by Karakum - do not modify it manually!

@file:JsModule("node:fs")

package node.fs

import node.stream.WritableOptions

/**
 * * Extends `stream.Writable`
 *
 * Instances of `fs.WriteStream` are created and returned using the {@link createWriteStream} function.
 * @since v0.1.93
 */
external class WriteStream : node.stream.Writable {
    constructor (opts: WritableOptions = definedExternally)

    /**
     * Closes `writeStream`. Optionally accepts a
     * callback that will be executed once the `writeStream`is closed.
     * @since v0.9.4
     */
    fun close(callback: (err: node.ErrnoException? /* use undefined for default */) -> Unit = definedExternally): Unit

    /**
     * The number of bytes written so far. Does not include data that is still queued
     * for writing.
     * @since v0.4.7
     */
    var bytesWritten: Double

    /**
     * The path to the file the stream is writing to as specified in the first
     * argument to {@link createWriteStream}. If `path` is passed as a string, then`writeStream.path` will be a string. If `path` is passed as a `Buffer`, then`writeStream.path` will be a
     * `Buffer`.
     * @since v0.1.93
     */
    var path: Any /* string | Buffer */

    /**
     * This property is `true` if the underlying file has not been opened yet,
     * i.e. before the `'ready'` event is emitted.
     * @since v11.2.0
     */
    var pending: Boolean

    /**
     * events.EventEmitter
     *   1. open
     *   2. close
     *   3. ready
     */


    override fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */

    override fun addListener(
        event: js.symbol.Symbol,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */


    override fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */

    override fun on(event: js.symbol.Symbol, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    override fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */

    override fun once(event: js.symbol.Symbol, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */


    override fun prependListener(
        event: String,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */

    override fun prependListener(
        event: js.symbol.Symbol,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */


    override fun prependOnceListener(
        event: String,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */

    override fun prependOnceListener(
        event: js.symbol.Symbol,
        listener: Function<Unit>, /* (...args: any[]) => void */
    ): Unit /* this */

    @web.events.JsEvent("close")
    override val closeEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("drain")
    override val drainEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("error")
    override val errorEvent: node.events.EventInstance<js.array.JsTuple1<js.errors.JsError>>

    @web.events.JsEvent("finish")
    override val finishEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("open")
    val openEvent: node.events.EventInstance<js.array.JsTuple1<Double>>

    @web.events.JsEvent("pipe")
    override val pipeEvent: node.events.EventInstance<js.array.JsTuple1<node.stream.Readable>>

    @web.events.JsEvent("ready")
    val readyEvent: node.events.EventInstance<js.array.JsTuple>

    @web.events.JsEvent("unpipe")
    override val unpipeEvent: node.events.EventInstance<js.array.JsTuple1<node.stream.Readable>>
}
