// Generated by Karakum - do not modify it manually!

package node.cluster

import node.events.EventEmitter

@Suppress("INTERFACE_WITH_SUPERCLASS")
sealed external interface Cluster : EventEmitter {
    fun disconnect(callback: () -> Unit = definedExternally): Unit

    /**
     * Spawn a new worker process.
     *
     * This can only be called from the primary process.
     * @param env Key/value pairs to add to worker process environment.
     * @since v0.6.0
     */
    fun fork(env: Any? = definedExternally): Worker

    /** @deprecated since v16.0.0 - use isPrimary. */
    val isMaster: Boolean

    /**
     * True if the process is a primary. This is determined by the `process.env.NODE_UNIQUE_ID`. If `process.env.NODE_UNIQUE_ID`
     * is undefined, then `isPrimary` is `true`.
     * @since v16.0.0
     */
    val isPrimary: Boolean

    /**
     * True if the process is not a primary (it is the negation of `cluster.isPrimary`).
     * @since v0.6.0
     */
    val isWorker: Boolean

    /**
     * The scheduling policy, either `cluster.SCHED_RR` for round-robin or `cluster.SCHED_NONE` to leave it to the operating system. This is a
     * global setting and effectively frozen once either the first worker is spawned, or [`.setupPrimary()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clustersetupprimarysettings)
     * is called, whichever comes first.
     *
     * `SCHED_RR` is the default on all operating systems except Windows. Windows will change to `SCHED_RR` once libuv is able to effectively distribute
     * IOCP handles without incurring a large performance hit.
     *
     * `cluster.schedulingPolicy` can also be set through the `NODE_CLUSTER_SCHED_POLICY` environment variable. Valid values are `'rr'` and `'none'`.
     * @since v0.11.2
     */
    var schedulingPolicy: Double

    /**
     * After calling [`.setupPrimary()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clustersetupprimarysettings)
     * (or [`.fork()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clusterforkenv)) this settings object will contain
     * the settings, including the default values.
     *
     * This object is not intended to be changed or set manually.
     * @since v0.7.1
     */
    val settings: ClusterSettings

    /** @deprecated since v16.0.0 - use [`.setupPrimary()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clustersetupprimarysettings) instead. */
    fun setupMaster(settings: ClusterSettings = definedExternally): Unit

    /**
     * `setupPrimary` is used to change the default 'fork' behavior. Once called, the settings will be present in `cluster.settings`.
     *
     * Any settings changes only affect future calls to [`.fork()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clusterforkenv)
     * and have no effect on workers that are already running.
     *
     * The only attribute of a worker that cannot be set via `.setupPrimary()` is the `env` passed to
     * [`.fork()`](https://nodejs.org/docs/latest-v20.x/api/cluster.html#clusterforkenv).
     *
     * The defaults above apply to the first call only; the defaults for later calls are the current values at the time of
     * `cluster.setupPrimary()` is called.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * cluster.setupPrimary({
     *   exec: 'worker.js',
     *   args: ['--use', 'https'],
     *   silent: true,
     * });
     * cluster.fork(); // https worker
     * cluster.setupPrimary({
     *   exec: 'worker.js',
     *   args: ['--use', 'http'],
     * });
     * cluster.fork(); // http worker
     * ```
     *
     * This can only be called from the primary process.
     * @since v16.0.0
     */
    fun setupPrimary(settings: ClusterSettings = definedExternally): Unit

    /**
     * A reference to the current worker object. Not available in the primary process.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * if (cluster.isPrimary) {
     *   console.log('I am primary');
     *   cluster.fork();
     *   cluster.fork();
     * } else if (cluster.isWorker) {
     *   console.log(`I am worker #${cluster.worker.id}`);
     * }
     * ```
     * @since v0.7.0
     */
    val worker: Worker?

    /**
     * A hash that stores the active worker objects, keyed by `id` field. This makes it easy to loop through all the workers. It is only available in the primary process.
     *
     * A worker is removed from `cluster.workers` after the worker has disconnected _and_ exited. The order between these two events cannot be determined in advance. However, it
     * is guaranteed that the removal from the `cluster.workers` list happens before the last `'disconnect'` or `'exit'` event is emitted.
     *
     * ```js
     * import cluster from 'node:cluster';
     *
     * for (const worker of Object.values(cluster.workers)) {
     *   worker.send('big announcement to all workers');
     * }
     * ```
     * @since v0.7.0
     */
    val workers: node.Dict<Worker>?
    val SCHED_NONE: Double
    val SCHED_RR: Double

    /**
     * events.EventEmitter
     *   1. disconnect
     *   2. exit
     *   3. fork
     *   4. listening
     *   5. message
     *   6. online
     *   7. setup
     */
    fun addListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    fun addListener(event: ClusterEvent.DISCONNECT, listener: (worker: Worker) -> Unit): Unit /* this */
    fun addListener(
        event: ClusterEvent.EXIT,
        listener: (worker: Worker, code: Double, signal: String) -> Unit,
    ): Unit /* this */

    fun addListener(event: ClusterEvent.FORK, listener: (worker: Worker) -> Unit): Unit /* this */
    fun addListener(
        event: ClusterEvent.LISTENING,
        listener: (worker: Worker, address: Address) -> Unit,
    ): Unit /* this */

    fun addListener(
        event: ClusterEvent.MESSAGE,
        listener: (worker: Worker, message: Any?, handle: Any /* net.Socket | net.Server */) -> Unit,
    ): Unit /* this */// the handle is a net.Socket or net.Server object, or undefined.

    fun addListener(event: ClusterEvent.ONLINE, listener: (worker: Worker) -> Unit): Unit /* this */
    fun addListener(event: ClusterEvent.SETUP, listener: (settings: ClusterSettings) -> Unit): Unit /* this */
    fun emit(event: String, vararg args: Any?): Boolean

    fun emit(event: js.symbol.Symbol, vararg args: Any?): Boolean
    fun emit(event: ClusterEvent.DISCONNECT, worker: Worker): Boolean
    fun emit(event: ClusterEvent.EXIT, worker: Worker, code: Number, signal: String): Boolean
    fun emit(event: ClusterEvent.FORK, worker: Worker): Boolean
    fun emit(event: ClusterEvent.LISTENING, worker: Worker, address: Address): Boolean
    fun emit(event: ClusterEvent.MESSAGE, worker: Worker, message: Any?, handle: node.net.Socket): Boolean

    fun emit(event: ClusterEvent.MESSAGE, worker: Worker, message: Any?, handle: node.net.Server): Boolean
    fun emit(event: ClusterEvent.ONLINE, worker: Worker): Boolean
    fun emit(event: ClusterEvent.SETUP, settings: ClusterSettings): Boolean
    fun on(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    fun on(event: ClusterEvent.DISCONNECT, listener: (worker: Worker) -> Unit): Unit /* this */
    fun on(event: ClusterEvent.EXIT, listener: (worker: Worker, code: Double, signal: String) -> Unit): Unit /* this */
    fun on(event: ClusterEvent.FORK, listener: (worker: Worker) -> Unit): Unit /* this */
    fun on(event: ClusterEvent.LISTENING, listener: (worker: Worker, address: Address) -> Unit): Unit /* this */
    fun on(
        event: ClusterEvent.MESSAGE,
        listener: (worker: Worker, message: Any?, handle: Any /* net.Socket | net.Server */) -> Unit,
    ): Unit /* this */// the handle is a net.Socket or net.Server object, or undefined.

    fun on(event: ClusterEvent.ONLINE, listener: (worker: Worker) -> Unit): Unit /* this */
    fun on(event: ClusterEvent.SETUP, listener: (settings: ClusterSettings) -> Unit): Unit /* this */
    fun once(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    fun once(event: ClusterEvent.DISCONNECT, listener: (worker: Worker) -> Unit): Unit /* this */
    fun once(
        event: ClusterEvent.EXIT,
        listener: (worker: Worker, code: Double, signal: String) -> Unit,
    ): Unit /* this */

    fun once(event: ClusterEvent.FORK, listener: (worker: Worker) -> Unit): Unit /* this */
    fun once(event: ClusterEvent.LISTENING, listener: (worker: Worker, address: Address) -> Unit): Unit /* this */
    fun once(
        event: ClusterEvent.MESSAGE,
        listener: (worker: Worker, message: Any?, handle: Any /* net.Socket | net.Server */) -> Unit,
    ): Unit /* this */// the handle is a net.Socket or net.Server object, or undefined.

    fun once(event: ClusterEvent.ONLINE, listener: (worker: Worker) -> Unit): Unit /* this */
    fun once(event: ClusterEvent.SETUP, listener: (settings: ClusterSettings) -> Unit): Unit /* this */
    fun prependListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    fun prependListener(event: ClusterEvent.DISCONNECT, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependListener(
        event: ClusterEvent.EXIT,
        listener: (worker: Worker, code: Double, signal: String) -> Unit,
    ): Unit /* this */

    fun prependListener(event: ClusterEvent.FORK, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependListener(
        event: ClusterEvent.LISTENING,
        listener: (worker: Worker, address: Address) -> Unit,
    ): Unit /* this */

    // the handle is a net.Socket or net.Server object, or undefined.
    fun prependListener(
        event: ClusterEvent.MESSAGE,
        listener: (worker: Worker, message: Any?, handle: (Any /* net.Socket | net.Server */)? /* use undefined for default */) -> Unit,
    ): Unit /* this */

    fun prependListener(event: ClusterEvent.ONLINE, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependListener(event: ClusterEvent.SETUP, listener: (settings: ClusterSettings) -> Unit): Unit /* this */
    fun prependOnceListener(event: String, listener: Function<Unit> /* (...args: any[]) => void */): Unit /* this */
    fun prependOnceListener(event: ClusterEvent.DISCONNECT, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependOnceListener(
        event: ClusterEvent.EXIT,
        listener: (worker: Worker, code: Double, signal: String) -> Unit,
    ): Unit /* this */

    fun prependOnceListener(event: ClusterEvent.FORK, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependOnceListener(
        event: ClusterEvent.LISTENING,
        listener: (worker: Worker, address: Address) -> Unit,
    ): Unit /* this */

    // the handle is a net.Socket or net.Server object, or undefined.
    fun prependOnceListener(
        event: ClusterEvent.MESSAGE,
        listener: (worker: Worker, message: Any?, handle: Any /* net.Socket | net.Server */) -> Unit,
    ): Unit /* this */

    fun prependOnceListener(event: ClusterEvent.ONLINE, listener: (worker: Worker) -> Unit): Unit /* this */
    fun prependOnceListener(event: ClusterEvent.SETUP, listener: (settings: ClusterSettings) -> Unit): Unit /* this */
}
