// Generated by Karakum - do not modify it manually!

package node.http

import node.net.Socket


@Suppress("NESTED_CLASS_IN_EXTERNAL_INTERFACE")
@seskar.js.JsVirtual
sealed external interface ClientRequestEvent {
    sealed interface ABORT : node.events.LegacyEventType
    sealed interface CONNECT : node.events.LegacyEventType
    sealed interface CONTINUE : node.events.LegacyEventType
    sealed interface INFORMATION : node.events.LegacyEventType
    sealed interface RESPONSE : node.events.LegacyEventType
    sealed interface SOCKET : node.events.LegacyEventType
    sealed interface TIMEOUT : node.events.LegacyEventType
    sealed interface UPGRADE : node.events.LegacyEventType
    sealed interface CLOSE : node.events.LegacyEventType
    sealed interface DRAIN : node.events.LegacyEventType
    sealed interface ERROR : node.events.LegacyEventType
    sealed interface FINISH : node.events.LegacyEventType
    sealed interface PIPE : node.events.LegacyEventType
    sealed interface UNPIPE : node.events.LegacyEventType

    companion object {
        @seskar.js.JsValue("abort")
        val ABORT: ABORT

        @seskar.js.JsValue("connect")
        val CONNECT: CONNECT

        @seskar.js.JsValue("continue")
        val CONTINUE: CONTINUE

        @seskar.js.JsValue("information")
        val INFORMATION: INFORMATION

        @seskar.js.JsValue("response")
        val RESPONSE: RESPONSE

        @seskar.js.JsValue("socket")
        val SOCKET: SOCKET

        @seskar.js.JsValue("timeout")
        val TIMEOUT: TIMEOUT

        @seskar.js.JsValue("upgrade")
        val UPGRADE: UPGRADE

        @seskar.js.JsValue("close")
        val CLOSE: CLOSE

        @seskar.js.JsValue("drain")
        val DRAIN: DRAIN

        @seskar.js.JsValue("error")
        val ERROR: ERROR

        @seskar.js.JsValue("finish")
        val FINISH: FINISH

        @seskar.js.JsValue("pipe")
        val PIPE: PIPE

        @seskar.js.JsValue("unpipe")
        val UNPIPE: UNPIPE

        @seskar.js.JsValue("abort")
        fun abort(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("connect")
        fun connect(): node.events.EventType<ClientRequest, js.array.JsTuple3<IncomingMessage, Socket, node.buffer.Buffer>>

        @seskar.js.JsValue("continue")
        fun `continue`(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("information")
        fun information(): node.events.EventType<ClientRequest, js.array.JsTuple1<InformationEvent>>

        @seskar.js.JsValue("response")
        fun response(): node.events.EventType<ClientRequest, js.array.JsTuple1<IncomingMessage>>

        @seskar.js.JsValue("socket")
        fun socket(): node.events.EventType<ClientRequest, js.array.JsTuple1<Socket>>

        @seskar.js.JsValue("timeout")
        fun timeout(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("upgrade")
        fun upgrade(): node.events.EventType<ClientRequest, js.array.JsTuple3<IncomingMessage, Socket, node.buffer.Buffer>>

        @seskar.js.JsValue("close")
        fun close(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("drain")
        fun drain(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("error")
        fun error(): node.events.EventType<ClientRequest, js.array.JsTuple1<Throwable /* JsError */>>

        @seskar.js.JsValue("finish")
        fun finish(): node.events.EventType<ClientRequest, js.array.JsTuple>

        @seskar.js.JsValue("pipe")
        fun pipe(): node.events.EventType<ClientRequest, js.array.JsTuple1<node.stream.Readable>>

        @seskar.js.JsValue("unpipe")
        fun unpipe(): node.events.EventType<ClientRequest, js.array.JsTuple1<node.stream.Readable>>
    }
}
