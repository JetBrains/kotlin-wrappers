// Generated by Karakum - do not modify it manually!

@file:JsModule("INTERNAL_ENTITY")

package electron.core

import js.promise.Promise
import node.buffer.Buffer
import node.events.EventEmitter as NodeEventEmitter

external class WebContents : NodeEventEmitter {
    /**
     * Emitted when media becomes audible or inaudible.
     */

    /**
     * Emitted before dispatching the `keydown` and `keyup` events in the page. Calling
     * `event.preventDefault` will prevent the page `keydown`/`keyup` events and the
     * menu shortcuts.
     *
     * To only prevent the menu shortcuts, use `setIgnoreMenuShortcuts`:
     */

    /**
     * Emitted when the `WebContents` loses focus.
     */

    /**
     * Emitted when failed to verify the `certificate` for `url`.
     *
     * The usage is the same with the `certificate-error` event of `app`.
     */

    /**
     * Emitted when the associated window logs a console message.
     */

    /**
     * Emitted when the page calls `window.moveTo`, `window.resizeTo` or related APIs.
     *
     * By default, this will move the window. To prevent that behavior, call
     * `event.preventDefault()`.
     */

    /**
     * Emitted when there is a new context menu that needs to be handled.
     */

    /**
     * Emitted when the cursor's type changes. The `type` parameter can be `pointer`,
     * `crosshair`, `hand`, `text`, `wait`, `help`, `e-resize`, `n-resize`,
     * `ne-resize`, `nw-resize`, `s-resize`, `se-resize`, `sw-resize`, `w-resize`,
     * `ns-resize`, `ew-resize`, `nesw-resize`, `nwse-resize`, `col-resize`,
     * `row-resize`, `m-panning`, `m-panning-vertical`, `m-panning-horizontal`,
     * `e-panning`, `n-panning`, `ne-panning`, `nw-panning`, `s-panning`, `se-panning`,
     * `sw-panning`, `w-panning`, `move`, `vertical-text`, `cell`, `context-menu`,
     * `alias`, `progress`, `nodrop`, `copy`, `none`, `not-allowed`, `zoom-in`,
     * `zoom-out`, `grab`, `grabbing`, `custom`, `null`, `drag-drop-none`,
     * `drag-drop-move`, `drag-drop-copy`, `drag-drop-link`, `ns-no-resize`,
     * `ew-no-resize`, `nesw-no-resize`, `nwse-no-resize`, or `default`.
     *
     * If the `type` parameter is `custom`, the `image` parameter will hold the custom
     * cursor image in a `NativeImage`, and `scale`, `size` and `hotspot` will hold
     * additional information about the custom cursor.
     */

    /**
     * Emitted when `webContents` is destroyed.
     */

    /**
     * Emitted when DevTools is closed.
     */

    /**
     * Emitted when DevTools is focused / opened.
     */

    /**
     * Emitted when a link is clicked in DevTools or 'Open in new tab' is selected for
     * a link in its context menu.
     */

    /**
     * Emitted when DevTools is opened.
     */

    /**
     * Emitted when the devtools window instructs the webContents to reload
     */

    /**
     * Emitted when 'Search' is selected for text in its context menu.
     */

    /**
     * Emitted when a `<webview>` has been attached to this web contents.
     */

    /**
     * Emitted when a page's theme color changes. This is usually due to encountering a
     * meta tag:
     */

    /**
     * Emitted _after_ successful creation of a window via `window.open` in the
     * renderer. Not emitted if the creation of the window is canceled from
     * `webContents.setWindowOpenHandler`.
     *
     * See `window.open()` for more details and how to use this in conjunction with
     * `webContents.setWindowOpenHandler`.
     */

    /**
     * This event is like `did-finish-load` but emitted when the load failed. The full
     * list of error codes and their meaning is available here.
     */

    /**
     * This event is like `did-fail-load` but emitted when the load was cancelled (e.g.
     * `window.stop()` was invoked).
     */

    /**
     * Emitted when the navigation is done, i.e. the spinner of the tab has stopped
     * spinning, and the `onload` event was dispatched.
     */

    /**
     * Emitted when a frame has done navigation.
     */

    /**
     * Emitted when any frame navigation is done.
     *
     * This event is not emitted for in-page navigations, such as clicking anchor links
     * or updating the `window.location.hash`. Use `did-navigate-in-page` event for
     * this purpose.
     */

    /**
     * Emitted when a main frame navigation is done.
     *
     * This event is not emitted for in-page navigations, such as clicking anchor links
     * or updating the `window.location.hash`. Use `did-navigate-in-page` event for
     * this purpose.
     */

    /**
     * Emitted when an in-page navigation happened in any frame.
     *
     * When in-page navigation happens, the page URL changes but does not cause
     * navigation outside of the page. Examples of this occurring are when anchor links
     * are clicked or when the DOM `hashchange` event is triggered.
     */

    /**
     * Emitted after a server side redirect occurs during navigation.  For example a
     * 302 redirect.
     *
     * This event cannot be prevented, if you want to prevent redirects you should
     * checkout out the `will-redirect` event above.
     */

    /**
     * Corresponds to the points in time when the spinner of the tab started spinning.
     */

    /**
     * Emitted when any frame (including main) starts navigating.
     */

    /**
     * Corresponds to the points in time when the spinner of the tab stopped spinning.
     */

    /**
     * Emitted when the document in the top-level frame is loaded.
     */

    /**
     * Emitted when the window enters a full-screen state triggered by HTML API.
     */

    /**
     * Emitted when the `WebContents` gains focus.
     *
     * Note that on macOS, having focus means the `WebContents` is the first responder
     * of window, so switching focus between windows would not trigger the `focus` and
     * `blur` events of `WebContents`, as the first responder of each window is not
     * changed.
     *
     * The `focus` and `blur` events of `WebContents` should only be used to detect
     * focus change between different `WebContents` and `BrowserView` in the same
     * window.
     */

    /**
     * Emitted when a result is available for `webContents.findInPage` request.
     */

    /**
     * Emitted when the mainFrame, an `<iframe>`, or a nested `<iframe>` is loaded
     * within the page.
     */

    /**
     * Emitted when an input event is sent to the WebContents. See InputEvent for
     * details.
     */

    /**
     * Emitted when the renderer process sends an asynchronous message via
     * `ipcRenderer.send()`.
     *
     * See also `webContents.ipc`, which provides an `IpcMain`-like interface for
     * responding to IPC messages specifically from this WebContents.
     */

    /**
     * Emitted when the renderer process sends a synchronous message via
     * `ipcRenderer.sendSync()`.
     *
     * See also `webContents.ipc`, which provides an `IpcMain`-like interface for
     * responding to IPC messages specifically from this WebContents.
     */

    /**
     * Emitted when the window leaves a full-screen state triggered by HTML API.
     */

    /**
     * Emitted when `webContents` wants to do basic auth.
     *
     * The usage is the same with the `login` event of `app`.
     */

    /**
     * Emitted when media is paused or done playing.
     */

    /**
     * Emitted when media starts playing.
     */

    /**
     * Emitted when page receives favicon urls.
     */

    /**
     * Fired when page title is set during navigation. `explicitSet` is false when
     * title is synthesized from file url.
     */

    /**
     * Emitted when a new frame is generated. Only the dirty area is passed in the
     * buffer.
     *
     * When using shared texture (set `webPreferences.offscreen.useSharedTexture` to
     * `true`) feature, you can pass the texture handle to external rendering pipeline
     * without the overhead of copying data between CPU and GPU memory, with Chromium's
     * hardware acceleration support. This feature is helpful for high-performance
     * rendering scenarios.
     *
     * Only a limited number of textures can exist at the same time, so it's important
     * that you call `texture.release()` as soon as you're done with the texture. By
     * managing the texture lifecycle by yourself, you can safely pass the
     * `texture.textureInfo` to other processes through IPC.
     */

    /**
     * Emitted when a plugin process has crashed.
     */

    /**
     * Emitted when the `WebContents` preferred size has changed.
     *
     * This event will only be emitted when `enablePreferredSizeMode` is set to `true`
     * in `webPreferences`.
     */

    /**
     * Emitted when the preload script `preloadPath` throws an unhandled exception
     * `error`.
     */

    /**
     * Emitted when the renderer process unexpectedly disappears.  This is normally
     * because it was crashed or killed.
     */

    /**
     * Emitted when the unresponsive web page becomes responsive again.
     */

    /**
     * Emitted when a bluetooth device needs to be selected when a call to
     * `navigator.bluetooth.requestDevice` is made. `callback` should be called with
     * the `deviceId` of the device to be selected.  Passing an empty string to
     * `callback` will cancel the request.
     *
     * If an event listener is not added for this event, or if `event.preventDefault`
     * is not called when handling this event, the first available device will be
     * automatically selected.
     *
     * Due to the nature of bluetooth, scanning for devices when
     * `navigator.bluetooth.requestDevice` is called may take time and will cause
     * `select-bluetooth-device` to fire multiple times until `callback` is called with
     * either a device id or an empty string to cancel the request.
     */

    /**
     * Emitted when a client certificate is requested.
     *
     * The usage is the same with the `select-client-certificate` event of `app`.
     */

    /**
     * Emitted when the web page becomes unresponsive.
     */

    /**
     * Emitted when mouse moves over a link or the keyboard moves the focus to a link.
     */

    /**
     * Emitted when a `<webview>`'s web contents is being attached to this web
     * contents. Calling `event.preventDefault()` will destroy the guest page.
     *
     * This event can be used to configure `webPreferences` for the `webContents` of a
     * `<webview>` before it's loaded, and provides the ability to set settings that
     * can't be set via `<webview>` attributes.
     */

    /**
     * Emitted when a user or the page wants to start navigation in any frame. It can
     * happen when the `window.location` object is changed or a user clicks a link in
     * the page.
     *
     * Unlike `will-navigate`, `will-frame-navigate` is fired when the main frame or
     * any of its subframes attempts to navigate. When the navigation event comes from
     * the main frame, `isMainFrame` will be `true`.
     *
     * This event will not emit when the navigation is started programmatically with
     * APIs like `webContents.loadURL` and `webContents.back`.
     *
     * It is also not emitted for in-page navigations, such as clicking anchor links or
     * updating the `window.location.hash`. Use `did-navigate-in-page` event for this
     * purpose.
     *
     * Calling `event.preventDefault()` will prevent the navigation.
     */

    /**
     * Emitted when a user or the page wants to start navigation on the main frame. It
     * can happen when the `window.location` object is changed or a user clicks a link
     * in the page.
     *
     * This event will not emit when the navigation is started programmatically with
     * APIs like `webContents.loadURL` and `webContents.back`.
     *
     * It is also not emitted for in-page navigations, such as clicking anchor links or
     * updating the `window.location.hash`. Use `did-navigate-in-page` event for this
     * purpose.
     *
     * Calling `event.preventDefault()` will prevent the navigation.
     */

    /**
     * Emitted when a `beforeunload` event handler is attempting to cancel a page
     * unload.
     *
     * Calling `event.preventDefault()` will ignore the `beforeunload` event handler
     * and allow the page to be unloaded.
     *
     * **Note:** This will be emitted for `BrowserViews` but will _not_ be respected -
     * this is because we have chosen not to tie the `BrowserView` lifecycle to its
     * owning BrowserWindow should one exist per the specification.
     */

    /**
     * Emitted when a server side redirect occurs during navigation.  For example a 302
     * redirect.
     *
     * This event will be emitted after `did-start-navigation` and always before the
     * `did-redirect-navigation` event for the same navigation.
     *
     * Calling `event.preventDefault()` will prevent the navigation (not just the
     * redirect).
     */

    /**
     * Emitted when the user is requesting to change the zoom level using the mouse
     * wheel.
     */

    /**
     * Adds the specified path to DevTools workspace. Must be used after DevTools
     * creation:
     */
    fun addWorkSpace(path: String)

    /**
     * Adjusts the current text selection starting and ending points in the focused
     * frame by the given amounts. A negative amount moves the selection towards the
     * beginning of the document, and a positive amount moves the selection towards the
     * end of the document.
     *
     * Example:
     *
     * For a call of `win.webContents.adjustSelection({ start: 1, end: 5 })`
     *
     * Before:
     *
     * After:
     */
    fun adjustSelection(options: AdjustSelectionOptions)

    /**
     * Begin subscribing for presentation events and captured frames, the `callback`
     * will be called with `callback(image, dirtyRect)` when there is a presentation
     * event.
     *
     * The `image` is an instance of NativeImage that stores the captured frame.
     *
     * The `dirtyRect` is an object with `x, y, width, height` properties that
     * describes which part of the page was repainted. If `onlyDirty` is set to `true`,
     * `image` will only contain the repainted area. `onlyDirty` defaults to `false`.
     */
    fun beginFrameSubscription(
        onlyDirty: Boolean,
        callback: (image: NativeImage, dirtyRect: Rectangle) -> Unit,
    )

    /**
     * Begin subscribing for presentation events and captured frames, the `callback`
     * will be called with `callback(image, dirtyRect)` when there is a presentation
     * event.
     *
     * The `image` is an instance of NativeImage that stores the captured frame.
     *
     * The `dirtyRect` is an object with `x, y, width, height` properties that
     * describes which part of the page was repainted. If `onlyDirty` is set to `true`,
     * `image` will only contain the repainted area. `onlyDirty` defaults to `false`.
     */
    fun beginFrameSubscription(callback: (image: NativeImage, dirtyRect: Rectangle) -> Unit)

    /**
     * Whether the browser can go back to previous web page.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.canGoBack` API.
     *
     * @deprecated
     */
    fun canGoBack(): Boolean

    /**
     * Whether the browser can go forward to next web page.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.canGoForward`
     * API.
     *
     * @deprecated
     */
    fun canGoForward(): Boolean

    /**
     * Whether the web page can go to `offset`.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.canGoToOffset`
     * API.
     *
     * @deprecated
     */
    fun canGoToOffset(offset: Double): Boolean

    /**
     * Resolves with a NativeImage
     *
     * Captures a snapshot of the page within `rect`. Omitting `rect` will capture the
     * whole visible page. The page is considered visible when its browser window is
     * hidden and the capturer count is non-zero. If you would like the page to stay
     * hidden, you should ensure that `stayHidden` is set to true.
     */
    fun capturePage(
        rect: Rectangle = definedExternally,
        opts: Opts = definedExternally,
    ): Promise<NativeImage>

    /**
     * Centers the current text selection in web page.
     */
    fun centerSelection()

    /**
     * Clears the navigation history.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.clear` API.
     *
     * @deprecated
     */
    fun clearHistory()

    /**
     * Closes the page, as if the web content had called `window.close()`.
     *
     * If the page is successfully closed (i.e. the unload is not prevented by the
     * page, or `waitForBeforeUnload` is false or unspecified), the WebContents will be
     * destroyed and no longer usable. The `destroyed` event will be emitted.
     */
    fun close(opts: CloseOpts = definedExternally)

    /**
     * Closes the devtools.
     */
    fun closeDevTools()

    /**
     * Executes the editing command `copy` in web page.
     */
    fun copy()

    /**
     * Copy the image at the given position to the clipboard.
     */
    fun copyImageAt(
        x: Double,
        y: Double,
    )

    /**
     * Executes the editing command `cut` in web page.
     */
    fun cut()

    /**
     * Executes the editing command `delete` in web page.
     */
    fun delete()

    /**
     * Disable device emulation enabled by `webContents.enableDeviceEmulation`.
     */
    fun disableDeviceEmulation()

    /**
     * Initiates a download of the resource at `url` without navigating. The
     * `will-download` event of `session` will be triggered.
     */
    fun downloadURL(
        url: String,
        options: DownloadURLOptions = definedExternally,
    )

    /**
     * Enable device emulation with the given parameters.
     */
    fun enableDeviceEmulation(parameters: Parameters)

    /**
     * End subscribing for frame presentation events.
     */
    fun endFrameSubscription()

    /**
     * A promise that resolves with the result of the executed code or is rejected if
     * the result of the code is a rejected promise.
     *
     * Evaluates `code` in page.
     *
     * In the browser window some HTML APIs like `requestFullScreen` can only be
     * invoked by a gesture from the user. Setting `userGesture` to `true` will remove
     * this limitation.
     *
     * Code execution will be suspended until web page stop loading.
     */
    fun executeJavaScript(
        code: String,
        userGesture: Boolean = definedExternally,
    ): Promise<Any?>

    /**
     * A promise that resolves with the result of the executed code or is rejected if
     * the result of the code is a rejected promise.
     *
     * Works like `executeJavaScript` but evaluates `scripts` in an isolated context.
     */
    fun executeJavaScriptInIsolatedWorld(
        worldId: Double,
        scripts: js.array.ReadonlyArray<WebSource>,
        userGesture: Boolean = definedExternally,
    ): Promise<Any?>

    /**
     * The request id used for the request.
     *
     * Starts a request to find all matches for the `text` in the web page. The result
     * of the request can be obtained by subscribing to `found-in-page` event.
     */
    fun findInPage(
        text: String,
        options: FindInPageOptions = definedExternally,
    ): Double

    /**
     * Focuses the web page.
     */
    fun focus()

    /**
     * Forcefully terminates the renderer process that is currently hosting this
     * `webContents`. This will cause the `render-process-gone` event to be emitted
     * with the `reason=killed || reason=crashed`. Please note that some webContents
     * share renderer processes and therefore calling this method may also crash the
     * host process for other webContents as well.
     *
     * Calling `reload()` immediately after calling this method will force the reload
     * to occur in a new process. This should be used when this process is unstable or
     * unusable, for instance in order to recover from the `unresponsive` event.
     */
    fun forcefullyCrashRenderer()

    /**
     * Information about all Shared Workers.
     */
    fun getAllSharedWorkers(): js.array.ReadonlyArray<SharedWorkerInfo>

    /**
     * whether or not this WebContents will throttle animations and timers when the
     * page becomes backgrounded. This also affects the Page Visibility API.
     */
    fun getBackgroundThrottling(): Boolean

    /**
     * the current title of the DevTools window. This will only be visible if DevTools
     * is opened in `undocked` or `detach` mode.
     */
    fun getDevToolsTitle(): String

    /**
     * If _offscreen rendering_ is enabled returns the current frame rate.
     */
    fun getFrameRate(): Double

    /**
     * The identifier of a WebContents stream. This identifier can be used with
     * `navigator.mediaDevices.getUserMedia` using a `chromeMediaSource` of `tab`. The
     * identifier is restricted to the web contents that it is registered to and is
     * only valid for 10 seconds.
     */
    fun getMediaSourceId(requestWebContents: WebContents): String

    /**
     * The operating system `pid` of the associated renderer process.
     */
    fun getOSProcessId(): Double

    /**
     * Get the system printer list.
     *
     * Resolves with a `PrinterInfo[]`
     */
    fun getPrintersAsync(): Promise<js.array.ReadonlyArray<PrinterInfo>>

    /**
     * The Chromium internal `pid` of the associated renderer. Can be compared to the
     * `frameProcessId` passed by frame specific navigation events (e.g.
     * `did-frame-navigate`)
     */
    fun getProcessId(): Double

    /**
     * The title of the current web page.
     */
    fun getTitle(): String

    /**
     * the type of the webContent. Can be `backgroundPage`, `window`, `browserView`,
     * `remote`, `webview` or `offscreen`.
     */
    fun getType(): (WebContentsGetTypeResult)

    /**
     * The URL of the current web page.
     */
    fun getURL(): String

    /**
     * The user agent for this web page.
     */
    fun getUserAgent(): String

    /**
     * Returns the WebRTC IP Handling Policy.
     */
    fun getWebRTCIPHandlingPolicy(): String

    /**
     * * `min` Integer - The minimum UDP port number that WebRTC should use.
     * * `max` Integer - The maximum UDP port number that WebRTC should use.
     *
     * By default this value is `{ min: 0, max: 0 }` , which would apply no restriction
     * on the udp port range.
     */
    fun getWebRTCUDPPortRange(): WebRTCUDPPortRange

    /**
     * the current zoom factor.
     */
    fun getZoomFactor(): Double

    /**
     * the current zoom level.
     */
    fun getZoomLevel(): Double

    /**
     * Makes the browser go back a web page.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.goBack` API.
     *
     * @deprecated
     */
    fun goBack()

    /**
     * Makes the browser go forward a web page.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.goForward` API.
     *
     * @deprecated
     */
    fun goForward()

    /**
     * Navigates browser to the specified absolute web page index.
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.goToIndex` API.
     *
     * @deprecated
     */
    fun goToIndex(index: Double)

    /**
     * Navigates to the specified offset from the "current entry".
     *
     * **Deprecated:** Should use the new `contents.navigationHistory.goToOffset` API.
     *
     * @deprecated
     */
    fun goToOffset(offset: Double)

    /**
     * A promise that resolves with a key for the inserted CSS that can later be used
     * to remove the CSS via `contents.removeInsertedCSS(key)`.
     *
     * Injects CSS into the current web page and returns a unique key for the inserted
     * stylesheet.
     */
    fun insertCSS(
        css: String,
        options: InsertCSSOptions = definedExternally,
    ): Promise<String>

    /**
     * Inserts `text` to the focused element.
     */
    fun insertText(text: String): Promise<js.core.Void>

    /**
     * Starts inspecting element at position (`x`, `y`).
     */
    fun inspectElement(
        x: Double,
        y: Double,
    )

    /**
     * Opens the developer tools for the service worker context.
     */
    fun inspectServiceWorker()

    /**
     * Opens the developer tools for the shared worker context.
     */
    fun inspectSharedWorker()

    /**
     * Inspects the shared worker based on its ID.
     */
    fun inspectSharedWorkerById(workerId: String)

    /**
     * Schedules a full repaint of the window this web contents is in.
     *
     * If _offscreen rendering_ is enabled invalidates the frame and generates a new
     * one through the `'paint'` event.
     */
    fun invalidate()

    /**
     * Whether this page has been muted.
     */
    fun isAudioMuted(): Boolean

    /**
     * Whether this page is being captured. It returns true when the capturer count is
     * greater than 0.
     */
    fun isBeingCaptured(): Boolean

    /**
     * Whether the renderer process has crashed.
     */
    fun isCrashed(): Boolean

    /**
     * Whether audio is currently playing.
     */
    fun isCurrentlyAudible(): Boolean

    /**
     * Whether the web page is destroyed.
     */
    fun isDestroyed(): Boolean

    /**
     * Whether the devtools view is focused .
     */
    fun isDevToolsFocused(): Boolean

    /**
     * Whether the devtools is opened.
     */
    fun isDevToolsOpened(): Boolean

    /**
     * Whether the web page is focused.
     */
    fun isFocused(): Boolean

    /**
     * Whether web page is still loading resources.
     */
    fun isLoading(): Boolean

    /**
     * Whether the main frame (and not just iframes or frames within it) is still
     * loading.
     */
    fun isLoadingMainFrame(): Boolean

    /**
     * Indicates whether _offscreen rendering_ is enabled.
     */
    fun isOffscreen(): Boolean

    /**
     * If _offscreen rendering_ is enabled returns whether it is currently painting.
     */
    fun isPainting(): Boolean

    /**
     * Whether the web page is waiting for a first-response from the main resource of
     * the page.
     */
    fun isWaitingForResponse(): Boolean

    /**
     * the promise will resolve when the page has finished loading (see
     * `did-finish-load`), and rejects if the page fails to load (see `did-fail-load`).
     *
     * Loads the given file in the window, `filePath` should be a path to an HTML file
     * relative to the root of your application.  For instance an app structure like
     * this:
     *
     * Would require code like this
     */
    fun loadFile(
        filePath: String,
        options: LoadFileOptions = definedExternally,
    ): Promise<js.core.Void>

    /**
     * the promise will resolve when the page has finished loading (see
     * `did-finish-load`), and rejects if the page fails to load (see `did-fail-load`).
     * A noop rejection handler is already attached, which avoids unhandled rejection
     * errors.
     *
     * Loads the `url` in the window. The `url` must contain the protocol prefix, e.g.
     * the `http://` or `file://`. If the load should bypass http cache then use the
     * `pragma` header to achieve it.
     */
    fun loadURL(
        url: String,
        options: LoadURLOptions = definedExternally,
    ): Promise<js.core.Void>

    /**
     * Opens the devtools.
     *
     * When `contents` is a `<webview>` tag, the `mode` would be `detach` by default,
     * explicitly passing an empty `mode` can force using last used dock state.
     *
     * On Windows, if Windows Control Overlay is enabled, Devtools will be opened with
     * `mode: 'detach'`.
     */
    fun openDevTools(options: OpenDevToolsOptions = definedExternally)

    /**
     * Executes the editing command `paste` in web page.
     */
    fun paste()

    /**
     * Executes the editing command `pasteAndMatchStyle` in web page.
     */
    fun pasteAndMatchStyle()

    /**
     * Send a message to the renderer process, optionally transferring ownership of
     * zero or more `MessagePortMain` objects.
     *
     * The transferred `MessagePortMain` objects will be available in the renderer
     * process by accessing the `ports` property of the emitted event. When they arrive
     * in the renderer, they will be native DOM `MessagePort` objects.
     *
     * For example:
     */
    fun postMessage(
        channel: String,
        message: Any?,
        transfer: js.array.ReadonlyArray<MessagePortMain> = definedExternally,
    )

    /**
     * When a custom `pageSize` is passed, Chromium attempts to validate platform
     * specific minimum values for `width_microns` and `height_microns`. Width and
     * height must both be minimum 353 microns but may be higher on some operating
     * systems.
     *
     * Prints window's web page. When `silent` is set to `true`, Electron will pick the
     * system's default printer if `deviceName` is empty and the default settings for
     * printing.
     *
     * Use `page-break-before: always;` CSS style to force to print to a new page.
     *
     * Example usage:
     */
    fun print(
        options: WebContentsPrintOptions = definedExternally,
        callback: (success: Boolean, failureReason: String) -> Unit = definedExternally,
    )

    /**
     * Resolves with the generated PDF data.
     *
     * Prints the window's web page as PDF.
     *
     * The `landscape` will be ignored if `@page` CSS at-rule is used in the web page.
     *
     * An example of `webContents.printToPDF`:
     *
     * See Page.printToPdf for more information.
     */
    fun printToPDF(options: PrintToPDFOptions): Promise<Buffer<*>>

    /**
     * Executes the editing command `redo` in web page.
     */
    fun redo()

    /**
     * Reloads the current web page.
     */
    fun reload()

    /**
     * Reloads current page and ignores cache.
     */
    fun reloadIgnoringCache()

    /**
     * Resolves if the removal was successful.
     *
     * Removes the inserted CSS from the current web page. The stylesheet is identified
     * by its key, which is returned from `contents.insertCSS(css)`.
     */
    fun removeInsertedCSS(key: String): Promise<js.core.Void>

    /**
     * Removes the specified path from DevTools workspace.
     */
    fun removeWorkSpace(path: String)

    /**
     * Executes the editing command `replace` in web page.
     */
    fun replace(text: String)

    /**
     * Executes the editing command `replaceMisspelling` in web page.
     */
    fun replaceMisspelling(text: String)

    /**
     * resolves if the page is saved.
     */
    fun savePage(
        fullPath: String,
        saveType: WebContentsSavePageSaveType,
    ): Promise<js.core.Void>

    /**
     * Scrolls to the bottom of the current `webContents`.
     */
    fun scrollToBottom()

    /**
     * Scrolls to the top of the current `webContents`.
     */
    fun scrollToTop()

    /**
     * Executes the editing command `selectAll` in web page.
     */
    fun selectAll()

    /**
     * Send an asynchronous message to the renderer process via `channel`, along with
     * arguments. Arguments will be serialized with the Structured Clone Algorithm,
     * just like `postMessage`, so prototype chains will not be included. Sending
     * Functions, Promises, Symbols, WeakMaps, or WeakSets will throw an exception.
     *
     * :::warning
     *
     * Sending non-standard JavaScript types such as DOM objects or special Electron
     * objects will throw an exception.
     *
     * :::
     *
     * For additional reading, refer to Electron's IPC guide.
     */
    fun send(
        channel: String,
        vararg args: Any?,
    )

    /**
     * Sends an input `event` to the page. **Note:** The `BrowserWindow` containing the
     * contents needs to be focused for `sendInputEvent()` to work.
     */
    fun sendInputEvent(inputEvent: MouseInputEvent)

    /**
     * Sends an input `event` to the page. **Note:** The `BrowserWindow` containing the
     * contents needs to be focused for `sendInputEvent()` to work.
     */
    fun sendInputEvent(inputEvent: MouseWheelInputEvent)

    /**
     * Sends an input `event` to the page. **Note:** The `BrowserWindow` containing the
     * contents needs to be focused for `sendInputEvent()` to work.
     */
    fun sendInputEvent(inputEvent: KeyboardInputEvent)

    /**
     * Send an asynchronous message to a specific frame in a renderer process via
     * `channel`, along with arguments. Arguments will be serialized with the
     * Structured Clone Algorithm, just like `postMessage`, so prototype chains will
     * not be included. Sending Functions, Promises, Symbols, WeakMaps, or WeakSets
     * will throw an exception.
     *
     * > **NOTE:** Sending non-standard JavaScript types such as DOM objects or special
     * Electron objects will throw an exception.
     *
     * The renderer process can handle the message by listening to `channel` with the
     * `ipcRenderer` module.
     *
     * If you want to get the `frameId` of a given renderer context you should use the
     * `webFrame.routingId` value.  E.g.
     *
     * You can also read `frameId` from all incoming IPC messages in the main process.
     */
    fun sendToFrame(
        frameId: Double,
        channel: String,
        vararg args: Any?,
    )

    /**
     * Send an asynchronous message to a specific frame in a renderer process via
     * `channel`, along with arguments. Arguments will be serialized with the
     * Structured Clone Algorithm, just like `postMessage`, so prototype chains will
     * not be included. Sending Functions, Promises, Symbols, WeakMaps, or WeakSets
     * will throw an exception.
     *
     * > **NOTE:** Sending non-standard JavaScript types such as DOM objects or special
     * Electron objects will throw an exception.
     *
     * The renderer process can handle the message by listening to `channel` with the
     * `ipcRenderer` module.
     *
     * If you want to get the `frameId` of a given renderer context you should use the
     * `webFrame.routingId` value.  E.g.
     *
     * You can also read `frameId` from all incoming IPC messages in the main process.
     */
    fun sendToFrame(
        frameId: js.array.Tuple2<Double, Double>,
        channel: String,
        vararg args: Any?,
    )

    /**
     * Mute the audio on the current web page.
     */
    fun setAudioMuted(muted: Boolean)

    /**
     * Controls whether or not this WebContents will throttle animations and timers
     * when the page becomes backgrounded. This also affects the Page Visibility API.
     */
    fun setBackgroundThrottling(allowed: Boolean)

    /**
     * Changes the title of the DevTools window to `title`. This will only be visible
     * if DevTools is opened in `undocked` or `detach` mode.
     */
    fun setDevToolsTitle(title: String)

    /**
     * Uses the `devToolsWebContents` as the target `WebContents` to show devtools.
     *
     * The `devToolsWebContents` must not have done any navigation, and it should not
     * be used for other purposes after the call.
     *
     * By default Electron manages the devtools by creating an internal `WebContents`
     * with native view, which developers have very limited control of. With the
     * `setDevToolsWebContents` method, developers can use any `WebContents` to show
     * the devtools in it, including `BrowserWindow`, `BrowserView` and `<webview>`
     * tag.
     *
     * Note that closing the devtools does not destroy the `devToolsWebContents`, it is
     * caller's responsibility to destroy `devToolsWebContents`.
     *
     * An example of showing devtools in a `<webview>` tag:
     *
     * An example of showing devtools in a `BrowserWindow`:
     */
    fun setDevToolsWebContents(devToolsWebContents: WebContents)

    /**
     * If _offscreen rendering_ is enabled sets the frame rate to the specified number.
     * Only values between 1 and 240 are accepted.
     */
    fun setFrameRate(fps: Double)

    /**
     * Ignore application menu shortcuts while this web contents is focused.
     */
    fun setIgnoreMenuShortcuts(ignore: Boolean)

    /**
     * Sets the image animation policy for this webContents.  The policy only affects
     * _new_ images, existing images that are currently being animated are unaffected.
     * This is a known limitation in Chromium, you can force image animation to be
     * recalculated with `img.src = img.src` which will result in no network traffic
     * but will update the animation policy.
     *
     * This corresponds to the animationPolicy accessibility feature in Chromium.
     */
    fun setImageAnimationPolicy(policy: WebContentsSetImageAnimationPolicyPolicy)

    /**
     * Overrides the user agent for this web page.
     */
    fun setUserAgent(userAgent: String)

    /**
     * Sets the maximum and minimum pinch-to-zoom level.
     *
     * > **NOTE**: Visual zoom is disabled by default in Electron. To re-enable it,
     * call:
     */
    fun setVisualZoomLevelLimits(
        minimumLevel: Double,
        maximumLevel: Double,
    ): Promise<js.core.Void>

    /**
     * Setting the WebRTC IP handling policy allows you to control which IPs are
     * exposed via WebRTC. See BrowserLeaks for more details.
     */
    fun setWebRTCIPHandlingPolicy(policy: WebContentsSetWebRTCIPHandlingPolicyPolicy)

    /**
     * Setting the WebRTC UDP Port Range allows you to restrict the udp port range used
     * by WebRTC. By default the port range is unrestricted. **Note:** To reset to an
     * unrestricted port range this value should be set to `{ min: 0, max: 0 }`.
     */
    fun setWebRTCUDPPortRange(udpPortRange: UdpPortRange)

    /**
     * Called before creating a window a new window is requested by the renderer, e.g.
     * by `window.open()`, a link with `target="_blank"`, shift+clicking on a link, or
     * submitting a form with `<form target="_blank">`. See `window.open()` for more
     * details and how to use this in conjunction with `did-create-window`.
     *
     * An example showing how to customize the process of new `BrowserWindow` creation
     * to be `BrowserView` attached to main window instead:
     */
    fun setWindowOpenHandler(handler: (details: HandlerDetails) -> WindowOpenHandlerResponse)

    /**
     * Changes the zoom factor to the specified factor. Zoom factor is zoom percent
     * divided by 100, so 300% = 3.0.
     *
     * The factor must be greater than 0.0.
     */
    fun setZoomFactor(factor: Double)

    /**
     * Changes the zoom level to the specified level. The original size is 0 and each
     * increment above or below represents zooming 20% larger or smaller to default
     * limits of 300% and 50% of original size, respectively. The formula for this is
     * `scale := 1.2 ^ level`.
     *
     * > **NOTE**: The zoom policy at the Chromium level is same-origin, meaning that
     * the zoom level for a specific domain propagates across all instances of windows
     * with the same domain. Differentiating the window URLs will make zoom work
     * per-window.
     */
    fun setZoomLevel(level: Double)

    /**
     * Shows pop-up dictionary that searches the selected word on the page.
     *
     * @platform darwin
     */
    fun showDefinitionForSelection()

    /**
     * Sets the `item` as dragging item for current drag-drop operation, `file` is the
     * absolute path of the file to be dragged, and `icon` is the image showing under
     * the cursor when dragging.
     */
    fun startDrag(item: Item)

    /**
     * If _offscreen rendering_ is enabled and not painting, start painting.
     */
    fun startPainting()

    /**
     * Stops any pending navigation.
     */
    fun stop()

    /**
     * Stops any `findInPage` request for the `webContents` with the provided `action`.
     */
    fun stopFindInPage(action: WebContentsStopFindInPageAction)

    /**
     * If _offscreen rendering_ is enabled and painting, stop painting.
     */
    fun stopPainting()

    /**
     * Indicates whether the snapshot has been created successfully.
     *
     * Takes a V8 heap snapshot and saves it to `filePath`.
     */
    fun takeHeapSnapshot(filePath: String): Promise<js.core.Void>

    /**
     * Toggles the developer tools.
     */
    fun toggleDevTools()

    /**
     * Executes the editing command `undo` in web page.
     */
    fun undo()

    /**
     * Executes the editing command `unselect` in web page.
     */
    fun unselect()

    /**
     * A `boolean` property that determines whether this page is muted.
     */
    var audioMuted: Boolean

    /**
     * A `boolean` property that determines whether or not this WebContents will
     * throttle animations and timers when the page becomes backgrounded. This also
     * affects the Page Visibility API.
     */
    var backgroundThrottling: Boolean

    /**
     * A `Debugger` instance for this webContents.
     *
     */
    val debugger: Debugger

    /**
     * A `WebContents | null` property that represents the of DevTools `WebContents`
     * associated with a given `WebContents`.
     *
     * **Note:** Users should never store this object because it may become `null` when
     * the DevTools has been closed.
     *
     */
    val devToolsWebContents: WebContents?

    /**
     * An `Integer` property that sets the frame rate of the web contents to the
     * specified number. Only values between 1 and 240 are accepted.
     *
     * Only applicable if _offscreen rendering_ is enabled.
     */
    var frameRate: Double

    /**
     * A `WebContents` instance that might own this `WebContents`.
     *
     */
    val hostWebContents: WebContents

    /**
     * A `Integer` representing the unique ID of this WebContents. Each ID is unique
     * among all `WebContents` instances of the entire Electron application.
     *
     */
    val id: Double

    /**
     * An `IpcMain` scoped to just IPC messages sent from this WebContents.
     *
     * IPC messages sent with `ipcRenderer.send`, `ipcRenderer.sendSync` or
     * `ipcRenderer.postMessage` will be delivered in the following order:
     *
     * * `contents.on('ipc-message')`
     * * `contents.mainFrame.on(channel)`
     * * `contents.ipc.on(channel)`
     * * `ipcMain.on(channel)`
     *
     * Handlers registered with `invoke` will be checked in the following order. The
     * first one that is defined will be called, the rest will be ignored.
     *
     * * `contents.mainFrame.handle(channel)`
     * * `contents.handle(channel)`
     * * `ipcMain.handle(channel)`
     *
     * A handler or event listener registered on the WebContents will receive IPC
     * messages sent from any frame, including child frames. In most cases, only the
     * main frame can send IPC messages. However, if the `nodeIntegrationInSubFrames`
     * option is enabled, it is possible for child frames to send IPC messages also. In
     * that case, handlers should check the `senderFrame` property of the IPC event to
     * ensure that the message is coming from the expected frame. Alternatively,
     * register handlers on the appropriate frame directly using the `WebFrameMain.ipc`
     * interface.
     *
     */
    val ipc: IpcMain

    /**
     * A `WebFrameMain` property that represents the top frame of the page's frame
     * hierarchy.
     *
     */
    val mainFrame: WebFrameMain

    /**
     * A `NavigationHistory` used by this webContents.
     *
     */
    val navigationHistory: NavigationHistory

    /**
     * A `WebFrameMain` property that represents the frame that opened this
     * WebContents, either with open(), or by navigating a link with a target
     * attribute.
     *
     */
    val opener: WebFrameMain

    /**
     * A `Session` used by this webContents.
     *
     */
    val session: Session

    /**
     * A `string` property that determines the user agent for this web page.
     */
    var userAgent: String

    /**
     * A `number` property that determines the zoom factor for this web contents.
     *
     * The zoom factor is the zoom percent divided by 100, so 300% = 3.0.
     */
    var zoomFactor: Double

    /**
     * A `number` property that determines the zoom level for this web contents.
     *
     * The original size is 0 and each increment above or below represents zooming 20%
     * larger or smaller to default limits of 300% and 50% of original size,
     * respectively. The formula for this is `scale := 1.2 ^ level`.
     */
    var zoomLevel: Double

    @web.events.JsEvent("audio-state-changed")
    val audioStateChangedEvent:
            node.events.EventInstance<js.array.Tuple1<Event<WebContentsAudioStateChangedEventParams>>>

    @web.events.JsEvent("before-input-event")
    val beforeInputEventEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, Input>>

    @web.events.JsEvent("blur")
    val blurEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("certificate-error")
    val certificateErrorEvent: node.events.EventInstance<
            js.array.Tuple6<
                    Event<*>,
                    String,
                    String,
                    Certificate,
                        (
                isTrusted: Boolean,
            ) -> Unit,
                    Boolean
                    >
            >

    @web.events.JsEvent("console-message")
    val consoleMessageEvent: node.events.EventInstance<js.array.Tuple5<Event<*>, Double, String, Double, String>>

    @web.events.JsEvent("content-bounds-updated")
    val contentBoundsUpdatedEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, Rectangle>>

    @web.events.JsEvent("context-menu")
    val contextMenuEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, ContextMenuParams>>

    @web.events.JsEvent("cursor-changed")
    val cursorChangedEvent:
            node.events.EventInstance<js.array.Tuple6<Event<*>, String, NativeImage, Double, Size, Point>>

    @web.events.JsEvent("destroyed")
    val destroyedEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("devtools-closed")
    val devtoolsClosedEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("devtools-focused")
    val devtoolsFocusedEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("devtools-open-url")
    val devtoolsOpenUrlEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, String>>

    @web.events.JsEvent("devtools-opened")
    val devtoolsOpenedEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("devtools-reload-page")
    val devtoolsReloadPageEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("devtools-search-query")
    val devtoolsSearchQueryEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, String>>

    @web.events.JsEvent("did-attach-webview")
    val didAttachWebviewEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, WebContents>>

    @web.events.JsEvent("did-change-theme-color")
    val didChangeThemeColorEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, String?>>

    @web.events.JsEvent("did-create-window")
    val didCreateWindowEvent: node.events.EventInstance<js.array.Tuple2<BrowserWindow, DidCreateWindowDetails>>

    @web.events.JsEvent("did-fail-load")
    val didFailLoadEvent:
            node.events.EventInstance<js.array.Tuple7<Event<*>, Double, String, String, Boolean, Double, Double>>

    @web.events.JsEvent("did-fail-provisional-load")
    val didFailProvisionalLoadEvent:
            node.events.EventInstance<js.array.Tuple7<Event<*>, Double, String, String, Boolean, Double, Double>>

    @web.events.JsEvent("did-finish-load")
    val didFinishLoadEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("did-frame-finish-load")
    val didFrameFinishLoadEvent: node.events.EventInstance<js.array.Tuple4<Event<*>, Boolean, Double, Double>>

    @web.events.JsEvent("did-frame-navigate")
    val didFrameNavigateEvent:
            node.events.EventInstance<js.array.Tuple7<Event<*>, String, Double, String, Boolean, Double, Double>>

    @web.events.JsEvent("did-navigate")
    val didNavigateEvent: node.events.EventInstance<js.array.Tuple4<Event<*>, String, Double, String>>

    @web.events.JsEvent("did-navigate-in-page")
    val didNavigateInPageEvent: node.events.EventInstance<js.array.Tuple5<Event<*>, String, Boolean, Double, Double>>

    @web.events.JsEvent("did-redirect-navigation")
    val didRedirectNavigationEvent:
            node.events.EventInstance<js.array.Tuple6<Event<WebContentsDidRedirectNavigationEventParams>, String, Boolean, Boolean, Double, Double>>

    @web.events.JsEvent("did-start-loading")
    val didStartLoadingEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("did-start-navigation")
    val didStartNavigationEvent:
            node.events.EventInstance<js.array.Tuple6<Event<WebContentsDidStartNavigationEventParams>, String, Boolean, Boolean, Double, Double>>

    @web.events.JsEvent("did-stop-loading")
    val didStopLoadingEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("dom-ready")
    val domReadyEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("enter-html-full-screen")
    val enterHtmlFullScreenEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("focus")
    val focusEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("found-in-page")
    val foundInPageEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, Result>>

    @web.events.JsEvent("frame-created")
    val frameCreatedEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, FrameCreatedDetails>>

    @web.events.JsEvent("input-event")
    val inputEventEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, InputEvent>>

    @web.events.JsEvent("ipc-message")
    val ipcMessageEvent: node.events.EventInstance<js.array.Tuple3<IpcMainEvent, String, js.array.ReadonlyArray<Any?>>>

    @web.events.JsEvent("ipc-message-sync")
    val ipcMessageSyncEvent:
            node.events.EventInstance<js.array.Tuple3<IpcMainEvent, String, js.array.ReadonlyArray<Any?>>>

    @web.events.JsEvent("leave-html-full-screen")
    val leaveHtmlFullScreenEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("login")
    val loginEvent: node.events.EventInstance<
            js.array.Tuple4<
                    Event<*>,
                    LoginAuthenticationResponseDetails,
                    AuthInfo,
                        (
                username: String?, /* use undefined for default */
                password: String?, // use undefined for default
            ) -> Unit
                    >
            >

    @web.events.JsEvent("media-paused")
    val mediaPausedEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("media-started-playing")
    val mediaStartedPlayingEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("page-favicon-updated")
    val pageFaviconUpdatedEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, js.array.ReadonlyArray<String>>>

    @web.events.JsEvent("page-title-updated")
    val pageTitleUpdatedEvent: node.events.EventInstance<js.array.Tuple3<Event<*>, String, Boolean>>

    @web.events.JsEvent("paint")
    val paintEvent:
            node.events.EventInstance<js.array.Tuple3<Event<WebContentsPaintEventParams>, Rectangle, NativeImage>>

    @web.events.JsEvent("plugin-crashed")
    val pluginCrashedEvent: node.events.EventInstance<js.array.Tuple3<Event<*>, String, String>>

    @web.events.JsEvent("preferred-size-changed")
    val preferredSizeChangedEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, Size>>

    @web.events.JsEvent("preload-error")
    val preloadErrorEvent: node.events.EventInstance<js.array.Tuple3<Event<*>, String, js.errors.JsError>>

    @web.events.JsEvent("render-process-gone")
    val renderProcessGoneEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, RenderProcessGoneDetails>>

    @web.events.JsEvent("responsive")
    val responsiveEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("select-bluetooth-device")
    val selectBluetoothDeviceEvent:
            node.events.EventInstance<
                    js.array.Tuple3<
                            Event<*>,
                            js.array.ReadonlyArray<BluetoothDevice>,
                                (
                        deviceId: String,
                    ) -> Unit
                            >
                    >

    @web.events.JsEvent("select-client-certificate")
    val selectClientCertificateEvent:
            node.events.EventInstance<
                    js.array.Tuple4<
                            Event<*>,
                            String,
                            js.array.ReadonlyArray<Certificate>,
                                (
                        certificate: Certificate,
                    ) -> Unit
                            >
                    >

    @web.events.JsEvent("unresponsive")
    val unresponsiveEvent: node.events.EventInstance<js.array.Tuple>

    @web.events.JsEvent("update-target-url")
    val updateTargetUrlEvent: node.events.EventInstance<js.array.Tuple2<Event<*>, String>>

    @web.events.JsEvent("will-attach-webview")
    val willAttachWebviewEvent:
            node.events.EventInstance<js.array.Tuple3<Event<*>, WebPreferences, js.objects.ReadonlyRecord<String, String>>>

    @web.events.JsEvent("will-frame-navigate")
    val willFrameNavigateEvent:
            node.events.EventInstance<js.array.Tuple1<Event<WebContentsWillFrameNavigateEventParams>>>

    @web.events.JsEvent("will-navigate")
    val willNavigateEvent:
            node.events.EventInstance<js.array.Tuple6<Event<WebContentsWillNavigateEventParams>, String, Boolean, Boolean, Double, Double>>

    @web.events.JsEvent("will-prevent-unload")
    val willPreventUnloadEvent: node.events.EventInstance<js.array.Tuple1<Event<*>>>

    @web.events.JsEvent("will-redirect")
    val willRedirectEvent:
            node.events.EventInstance<js.array.Tuple6<Event<WebContentsWillRedirectEventParams>, String, Boolean, Boolean, Double, Double>>

    @web.events.JsEvent("zoom-changed")
    val zoomChangedEvent:
            node.events.EventInstance<js.array.Tuple2<Event<*>, (WebContentsAddListenerListenerZoomDirection)>>

    companion object {
// Docs: https://electronjs.org/docs/api/web-contents
        /**
         * A WebContents instance with the given TargetID, or `undefined` if there is no
         * WebContents associated with the given TargetID.
         *
         * When communicating with the Chrome DevTools Protocol, it can be useful to lookup
         * a WebContents instance based on its assigned TargetID.
         */
        fun fromDevToolsTargetId(targetId: String): WebContents?

        /**
         * A WebContents instance with the given WebFrameMain, or `undefined` if there is
         * no WebContents associated with the given WebFrameMain.
         */
        fun fromFrame(frame: WebFrameMain): WebContents?

        /**
         * A WebContents instance with the given ID, or `undefined` if there is no
         * WebContents associated with the given ID.
         */
        fun fromId(id: Double): WebContents?

        /**
         * An array of all `WebContents` instances. This will contain web contents for all
         * windows, webviews, opened devtools, and devtools extension background pages.
         */
        fun getAllWebContents(): js.array.ReadonlyArray<WebContents>

        /**
         * The web contents that is focused in this application, otherwise returns `null`.
         */
        fun getFocusedWebContents(): WebContents?
    }
}
